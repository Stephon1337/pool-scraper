<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AquaDesk - Verifier</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        /* Hide duplicate nav when inside AquaDesk dashboard iframe */
        .in-iframe .header .logo,
        .in-iframe .header .nav-tabs { display: none !important; }
        :root {
            --bg: #0a0a0f;
            --bg-card: #12121a;
            --bg-hover: #1a1a24;
            --border: #2a2a35;
            --text: #e4e4e7;
            --text-dim: #71717a;
            --accent: #06b6d4;
            --green: #22c55e;
            --orange: #f59e0b;
            --red: #ef4444;
            --purple: #8b5cf6;
        }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); font-size: 13px; height: 100vh; display: flex; flex-direction: column; }

        /* Header */
        .header { display: flex; align-items: center; padding: 8px 16px; background: var(--bg-card); border-bottom: 1px solid var(--border); gap: 12px; }
        .logo { font-weight: 700; font-size: 15px; color: var(--text); display: flex; align-items: center; gap: 8px; }
        .logo span { color: var(--accent); }
        .nav-tabs { display: flex; gap: 4px; margin-left: 16px; }
        .nav-tab { padding: 6px 14px; border-radius: 6px; cursor: pointer; color: var(--text-dim); font-size: 12px; font-weight: 500; text-decoration: none; display: flex; align-items: center; gap: 6px; background: var(--bg-hover); transition: all 0.15s; }
        .nav-tab:hover { background: var(--accent); color: #000; }
        .nav-tab.active { background: var(--accent); color: #000; }
        .header-controls { display: flex; gap: 8px; margin-left: auto; align-items: center; }
        .btn { padding: 8px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.15s; }
        .btn-primary { background: var(--accent); color: #000; }
        .btn-primary:hover { filter: brightness(1.1); }
        .btn-success { background: var(--green); color: #000; }
        .btn-danger { background: var(--red); color: white; }
        .btn-secondary { background: var(--bg-hover); color: var(--text); border: 1px solid var(--border); }
        .btn-lg { padding: 12px 24px; font-size: 14px; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Main Layout */
        .main { flex: 1; display: flex; overflow: hidden; }

        /* Sidebar */
        .sidebar { width: 380px; background: var(--bg-card); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }

        /* Stats Bar */
        .stats-bar { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; padding: 12px; border-bottom: 1px solid var(--border); }
        .stat { text-align: center; padding: 8px; background: var(--bg); border-radius: 6px; }
        .stat-value { font-size: 20px; font-weight: 700; }
        .stat-value.cyan { color: var(--accent); }
        .stat-value.green { color: var(--green); }
        .stat-value.red { color: var(--red); }
        .stat-value.orange { color: var(--orange); }
        .stat-label { font-size: 9px; color: var(--text-dim); text-transform: uppercase; margin-top: 2px; }

        /* Filter Bar */
        .filter-bar { display: flex; gap: 6px; padding: 10px 12px; border-bottom: 1px solid var(--border); align-items: center; flex-wrap: wrap; }
        .filter-bar select { padding: 6px 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 11px; }
        .filter-bar input { padding: 6px 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 11px; flex: 1; min-width: 120px; }

        /* Address List */
        .address-list { flex: 1; overflow-y: auto; }
        .address-item { padding: 10px 12px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; display: flex; gap: 10px; align-items: flex-start; }
        .address-item:hover { background: var(--bg-hover); }
        .address-item.active { background: var(--accent); color: #000; }
        .address-item.active .addr-city, .address-item.active .addr-status { color: #000; }
        .address-item.verified { border-left: 3px solid var(--green); }
        .address-item.no-pool { border-left: 3px solid var(--red); }
        .address-item.pending { border-left: 3px solid var(--orange); }
        .addr-num { font-size: 10px; color: var(--text-dim); min-width: 30px; }
        .address-item.active .addr-num { color: #000; }
        .addr-info { flex: 1; min-width: 0; }
        .addr-name { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .addr-street { font-size: 11px; color: var(--text-dim); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .address-item.active .addr-street { color: rgba(0,0,0,0.7); }
        .addr-city { font-size: 10px; color: var(--text-dim); }
        .addr-status { font-size: 18px; min-width: 24px; text-align: center; }

        /* Map Container */
        .map-area { flex: 1; display: flex; flex-direction: column; }

        /* Current Address Panel */
        .current-panel { padding: 12px 16px; background: var(--bg-card); border-bottom: 1px solid var(--border); }
        .current-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
        .current-name { font-size: 18px; font-weight: 700; color: var(--accent); }
        .current-address { color: var(--text-dim); font-size: 13px; }
        .current-details { display: flex; gap: 16px; margin-top: 10px; flex-wrap: wrap; }
        .detail-item { display: flex; flex-direction: column; }
        .detail-label { font-size: 9px; color: var(--text-dim); text-transform: uppercase; }
        .detail-value { font-size: 14px; font-weight: 600; }

        /* Action Panel */
        .action-panel { padding: 12px 16px; background: var(--bg-card); border-bottom: 1px solid var(--border); display: flex; gap: 10px; align-items: center; }
        .action-buttons { display: flex; gap: 8px; }
        .btn-pool { background: var(--green); color: #000; padding: 10px 20px; font-size: 14px; }
        .btn-pool:hover { filter: brightness(1.1); }
        .btn-nopool { background: var(--red); color: white; padding: 10px 20px; font-size: 14px; }
        .btn-nopool:hover { filter: brightness(1.1); }
        .btn-pending { background: var(--orange); color: #000; padding: 10px 20px; font-size: 14px; }
        .nav-buttons { display: flex; gap: 6px; margin-left: auto; }
        .keyboard-hints { font-size: 10px; color: var(--text-dim); margin-left: 12px; }
        .keyboard-hints kbd { background: var(--bg); padding: 2px 6px; border-radius: 3px; color: var(--accent); }

        /* Map */
        #map { flex: 1; background: #1a1a2e; position: relative; min-height: 0; overflow: hidden; }
        #mapFrame { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }


        /* Modal */
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 2000; }
        .modal.show { display: flex; }
        .modal-content { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; width: 450px; max-width: 90%; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .modal-header h3 { font-size: 16px; }
        .modal-close { background: none; border: none; color: var(--text-dim); font-size: 24px; cursor: pointer; }
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; font-size: 11px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 4px; }
        .form-group input, .form-group select { width: 100%; padding: 8px 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 13px; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .modal-actions { display: flex; gap: 10px; margin-top: 20px; }
        .modal-actions .btn { flex: 1; }

        /* Toast */
        .toast { position: fixed; bottom: 20px; right: 20px; background: var(--bg-card); border: 1px solid var(--border); padding: 12px 20px; border-radius: 8px; z-index: 3000; transform: translateY(100px); opacity: 0; transition: all 0.3s; }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { border-color: var(--green); }
        .toast.error { border-color: var(--red); }

        /* Empty State */
        .empty-state { flex: 1; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 16px; color: var(--text-dim); }
        .empty-state h2 { color: var(--text); font-size: 18px; }
        .upload-zone { border: 2px dashed var(--border); border-radius: 12px; padding: 40px 60px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover { border-color: var(--accent); background: rgba(6, 182, 212, 0.05); }

        /* History Panel */
        .history-panel { max-height: 200px; overflow-y: auto; margin-top: 12px; }
        .history-item { font-size: 11px; padding: 6px 0; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; }
        .history-time { color: var(--text-dim); }

        input[type="file"] { display: none; }

        /* Progress Bar */
        .progress-bar-container { padding: 8px 12px; border-bottom: 1px solid var(--border); }
        .progress-bar-label { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-dim); margin-bottom: 4px; }
        .progress-bar { height: 8px; background: var(--bg); border-radius: 4px; overflow: hidden; }
        .progress-bar-fill { height: 100%; background: linear-gradient(90deg, var(--green), var(--accent)); transition: width 0.3s ease; border-radius: 4px; }

        /* Bulk Select */
        .bulk-checkbox { width: 16px; height: 16px; cursor: pointer; accent-color: var(--accent); }
        .bulk-action-bar { padding: 8px 12px; background: var(--accent); color: #000; display: none; align-items: center; gap: 10px; font-size: 12px; font-weight: 600; }
        .bulk-action-bar.show { display: flex; }
        .bulk-action-bar button { background: rgba(0,0,0,0.2); border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; color: #000; font-weight: 600; }
        .bulk-action-bar button:hover { background: rgba(0,0,0,0.3); }

        /* Value Filter */
        .value-filter { display: flex; align-items: center; gap: 4px; }
        .value-filter input { width: 70px !important; flex: none !important; min-width: auto !important; }
        .value-filter span { font-size: 10px; color: var(--text-dim); }
    </style>
</head>
<body>
    <script>if(window.self!==window.top)document.documentElement.classList.add('in-iframe');</script>
    <div class="header">
        <div class="logo">üíß Aqua<span>Desk</span></div>
        <div class="nav-tabs">
            <a href="pool-scraper.html" class="nav-tab">üìã Scraper</a>
            <a href="#" class="nav-tab active">üîç Verifier</a>
            <a href="postcard.html" class="nav-tab">üé® Postcard</a>
        </div>
        <div class="header-controls">
            <button class="btn btn-secondary" onclick="openAddModal()">‚ûï Add</button>
            <button class="btn btn-primary" onclick="loadFromScraper()">üì• Load from Scraper</button>
            <button class="btn btn-secondary" onclick="showImportModal()">üì• Import CSV</button>
            <button class="btn btn-primary" onclick="exportVerified()">üì§ Export</button>
            <button class="btn btn-secondary" onclick="sortByRoute(); openGoogleMapsRoute();">üó∫Ô∏è Route</button>
            <button class="btn btn-secondary" style="color:var(--red);" onclick="clearAllData()">üóëÔ∏è</button>
            <button class="btn btn-secondary" onclick="showHelp()">‚ùì</button>
        </div>
    </div>


    <div class="main">
        <div class="sidebar">
            <div class="stats-bar" style="grid-template-columns: repeat(5, 1fr);">
                <div class="stat">
                    <div class="stat-value cyan" id="statTotal">0</div>
                    <div class="stat-label">Total</div>
                </div>
                <div class="stat">
                    <div class="stat-value green" id="statVerified">0</div>
                    <div class="stat-label">Has Pool</div>
                </div>
                <div class="stat">
                    <div class="stat-value red" id="statNoPool">0</div>
                    <div class="stat-label">No Pool</div>
                </div>
                <div class="stat">
                    <div class="stat-value orange" id="statPending">0</div>
                    <div class="stat-label">Pending</div>
                </div>
                <div class="stat">
                    <div class="stat-value" style="color:var(--cyan);" id="statMailed">0</div>
                    <div class="stat-label">Mailed</div>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="progress-bar-container">
                <div class="progress-bar-label">
                    <span id="progressText">0 / 0 verified</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="progressFill" style="width: 0%;"></div>
                </div>
            </div>

            <!-- Bulk Action Bar -->
            <div class="bulk-action-bar" id="bulkActionBar">
                <input type="checkbox" class="bulk-checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()" title="Select All">
                <span id="bulkSelectedCount">0 selected</span>
                <button onclick="bulkMarkAs('verified')">‚úÖ Has Pool</button>
                <button onclick="bulkMarkAs('no-pool')">‚ùå No Pool</button>
                <button onclick="bulkMarkAsMailed()">üì¨ Mark Mailed</button>
                <button onclick="clearBulkSelection()" style="margin-left:auto;">‚úï Clear</button>
            </div>

            <div class="filter-bar">
                <select id="statusFilter" onchange="filterList()">
                    <option value="all">All Status</option>
                    <option value="unreviewed">Unreviewed</option>
                    <option value="verified">‚úÖ Has Pool</option>
                    <option value="no-pool">‚ùå No Pool</option>
                    <option value="pending">‚è≥ Pending</option>
                </select>
                <select id="subdivisionFilter" onchange="filterList()" style="max-width:180px;">
                    <option value="all">All Subdivisions</option>
                </select>
                <input type="text" id="searchInput" placeholder="Search..." oninput="filterList()">
                <button class="btn" style="background:#10b981; color:#000; padding:6px 10px;" onclick="plotSubdivisionRoute()" title="Plot walking route for selected subdivision">üö∂ Walk Route</button>
            </div>
            <div class="filter-bar" style="border-bottom:none; padding-top:0;">
                <span style="font-size:11px; color:var(--text-dim);">Go to #</span>
                <input type="number" id="jumpToInput" min="1" placeholder="1" style="width:70px;" onkeydown="if(event.key==='Enter')jumpToAddress()">
                <button class="btn btn-secondary" onclick="jumpToAddress()" style="padding:6px 10px;">Go</button>
                <button class="btn" style="background:var(--orange); color:#000; padding:6px 10px;" onclick="skipToUnverified()" title="Jump to next unreviewed">‚è≠Ô∏è Skip</button>
                <button class="btn btn-secondary" id="undoBtn" onclick="undoLastAction()" style="padding:6px 10px;" disabled title="Undo last action">‚Ü©Ô∏è Undo</button>
                <span style="font-size:11px; color:var(--text-dim); margin-left:auto;" id="positionInfo">0 / 0</span>
            </div>

            <div class="address-list" id="addressList">
                <div class="empty-state">
                    <p>Load a CSV to begin</p>
                </div>
            </div>
        </div>

        <div class="map-area">
            <div class="current-panel" id="currentPanel" style="display:none;">
                <div class="current-header">
                    <div>
                        <div class="current-name" id="currentName">-</div>
                        <div class="current-address" id="currentAddress">-</div>
                    </div>
                    <div id="currentStatus" style="font-size:24px;">‚¨ú</div>
                </div>
                <div class="current-details" id="currentDetails"></div>
            </div>

            <div class="action-panel" id="actionPanel" style="display:none;">
                <div class="action-buttons">
                    <button class="btn btn-pool" onclick="markAs('verified')">‚úÖ Has Pool</button>
                    <button class="btn btn-nopool" onclick="markAs('no-pool')">‚ùå No Pool</button>
                    <button class="btn btn-pending" onclick="markAs('pending')">‚è≥ Pending</button>
                    <button class="btn" style="background:var(--cyan); color:#000;" onclick="markAsMailed()">üì¨ Mailed</button>
                </div>
                <div class="nav-buttons">
                    <button class="btn btn-secondary" onclick="goToPrev()">‚óÄ Prev</button>
                    <button class="btn btn-secondary" onclick="goToNext()">Next ‚ñ∂</button>
                    <button class="btn btn-secondary" onclick="openInGoogleMaps()" title="Open in Google Maps">üó∫Ô∏è</button>
                </div>
                <div class="keyboard-hints">
                    <kbd>Y</kbd> Pool <kbd>N</kbd> No <kbd>P</kbd> Pending <kbd>M</kbd> Mailed <kbd>S</kbd> Skip <kbd>U</kbd> Undo <kbd>‚Üê</kbd><kbd>‚Üí</kbd> Nav <kbd>G</kbd> Maps
                </div>
            </div>

            <div id="map">
                <iframe id="mapFrame" allowfullscreen loading="lazy"></iframe>
            </div>

            <div class="empty-state" id="emptyMap">
                <div class="upload-zone" onclick="document.getElementById('fileInput').click()">
                    <h2>üìÅ Drop CSV or Click to Upload</h2>
                    <p>Load addresses from Pool Scraper to verify</p>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".csv" onchange="loadCSV(event)">

    <!-- Add Address Modal -->
    <div class="modal" id="addModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üè† Add New Address</h3>
                <button class="modal-close" onclick="closeAddModal()">&times;</button>
            </div>
            <div class="form-group">
                <label>Recipient Name</label>
                <input type="text" id="addName" value="Current Resident">
            </div>
            <div class="form-group">
                <label>Street Address</label>
                <input type="text" id="addStreet" placeholder="123 Main St">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>City</label>
                    <input type="text" id="addCity">
                </div>
                <div class="form-group">
                    <label>State</label>
                    <input type="text" id="addState" value="FL">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Zip Code</label>
                    <input type="text" id="addZip">
                </div>
                <div class="form-group">
                    <label>Status</label>
                    <select id="addStatus">
                        <option value="verified">‚úÖ Has Pool</option>
                        <option value="pending">‚è≥ Pending</option>
                    </select>
                </div>
            </div>
            <div id="addModalInfo" style="font-size:11px; color:var(--text-dim); margin-top:8px;"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeAddModal()">Cancel</button>
                <button class="btn btn-success" onclick="addNewAddress()">Add Address</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üì§ Export Verified Addresses</h3>
                <button class="modal-close" onclick="closeExportModal()">&times;</button>
            </div>
            <p style="font-size:12px; color:var(--text-dim); margin-bottom:12px;">Select columns to include (exported in order shown):</p>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expRecipient" checked> 1. Recipient
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expCompany" checked> 2. Company
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expAddress" checked> 3. Address
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expCity" checked> 4. City
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expState" checked> 5. State
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expZip" checked> 6. Zipcode
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px; border-top:1px solid var(--border); padding-top:8px; grid-column:span 2;">
                    <strong style="color:var(--text-dim); font-size:11px;">Additional columns:</strong>
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expValue"> Property Value
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expYear"> Year Built
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expAge"> Pool Age
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expVerifiedAt"> Verified Date
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expStatus"> Status
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expSubdivision"> Subdivision
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expSaleDate"> Sale Date
                </label>
            </div>
            <div style="margin-top:16px;">
                <label style="font-size:11px; color:var(--text-dim);">Export which addresses:</label>
                <select id="exportFilter" style="width:100%; margin-top:4px; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--bg); color:var(--text);" onchange="updateExportCount()">
                    <option value="verified">‚úÖ Has Pool only</option>
                    <option value="all-reviewed">All reviewed (Pool + No Pool)</option>
                    <option value="all">All addresses</option>
                </select>
            </div>
            <div style="margin-top:12px;">
                <label style="display:flex; align-items:center; gap:8px; font-size:12px;">
                    <input type="checkbox" id="expRouteFormat"> Export as Route CSV (for GPS/mapping)
                </label>
            </div>
            <div id="exportCount" style="margin-top:12px; font-size:12px; color:var(--accent);"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeExportModal()">Cancel</button>
                <button class="btn btn-success" onclick="doExport()">Export CSV</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üì• Import Addresses</h3>
                <button class="modal-close" onclick="closeImportModal()">&times;</button>
            </div>
            <div class="upload-zone" onclick="document.getElementById('fileInput').click()" style="padding:30px;">
                <h2>üìÅ Select CSV File</h2>
                <p>VistaPrint format or Pool Scraper export</p>
            </div>
            <div style="margin-top:16px; text-align:center; color:var(--text-dim); font-size:12px;">
                Or drag & drop a file anywhere on the page
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal" id="helpModal">
        <div class="modal-content" style="width:600px; max-height:85vh; overflow-y:auto;">
            <div class="modal-header">
                <h3>‚ùì Pool Verifier Pro Help</h3>
                <button class="modal-close" onclick="closeHelp()">&times;</button>
            </div>
            <div style="font-size:12px; line-height:1.6;">
                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üéØ Purpose</h4>
                <p style="color:var(--text-dim); margin-bottom:12px;">
                    Pool Verifier Pro lets you visually confirm whether properties have pools using Google Maps satellite imagery.
                    This eliminates wasted postcards sent to homes without pools.
                </p>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üì• Loading Data</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Load from Scraper:</strong> Click to import addresses synced from Pool Scraper Pro (recommended workflow)</li>
                    <li><strong>Import CSV:</strong> Upload any CSV with address columns (Recipient, Address, City, State, Zip)</li>
                    <li><strong>Drag & Drop:</strong> Drop a CSV file anywhere on the page</li>
                    <li><strong>Add Address:</strong> Manually add individual addresses</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üîç Verification Process</h4>
                <ol style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li>Select an address from the list on the left</li>
                    <li>Examine the satellite view for a pool (blue rectangle in backyard)</li>
                    <li>Mark as: <span style="color:var(--green);">‚úÖ Has Pool</span>, <span style="color:var(--red);">‚ùå No Pool</span>, or <span style="color:var(--orange);">‚è≥ Pending</span></li>
                    <li>Tool auto-advances to next unreviewed address</li>
                </ol>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">‚å®Ô∏è Keyboard Shortcuts</h4>
                <table style="width:100%; border-collapse:collapse; margin-bottom:12px;">
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">Y</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Mark as Has Pool (Yes)</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">N</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Mark as No Pool</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">P</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Mark as Pending (unclear imagery)</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">‚Üê</kbd> <kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">‚Üí</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Navigate previous / next address</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">G</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Open current address in Google Maps</td>
                    </tr>
                </table>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üîÑ Status Colors</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><span style="color:var(--green);">Green border</span> = Verified (has pool)</li>
                    <li><span style="color:var(--red);">Red border</span> = No Pool</li>
                    <li><span style="color:var(--orange);">Orange border</span> = Pending review</li>
                    <li>No border = Unreviewed</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üîó Integration with Pool Scraper</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Import:</strong> Use "Load from Scraper" after clicking "Sync to Verifier" in Pool Scraper</li>
                    <li><strong>No-Pool Sync:</strong> Addresses marked ‚ùå No Pool are automatically excluded from Pool Scraper exports when "Exclude No Pool" is checked</li>
                    <li>Both tools share verification status via browser storage</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üì§ Exporting</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Export Verified:</strong> Download CSV of addresses with confirmed pools</li>
                    <li>Choose which columns to include (Recipient, Address, City, State, Zip, etc.)</li>
                    <li>Filter options: Has Pool only, All reviewed, or All addresses</li>
                    <li>VistaPrint-compatible format for postcard printing</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üìä Filtering & Navigation</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Status Filter:</strong> Show All, Unreviewed, Has Pool, No Pool, or Pending</li>
                    <li><strong>Search:</strong> Filter by address or name</li>
                    <li><strong>Go to #:</strong> Jump directly to a specific address number</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üí° Tips</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li>Pools appear as blue rectangles, usually in the backyard</li>
                    <li>Use "Pending" for addresses with tree cover or unclear imagery</li>
                    <li>Press <kbd style="background:var(--bg); padding:2px 6px; border-radius:3px; color:var(--accent);">G</kbd> to open in Google Maps for street view or better zoom</li>
                    <li>Your progress is auto-saved - close and return anytime</li>
                    <li>Filter to "Unreviewed" to focus on addresses that need verification</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üíæ Data Storage</h4>
                <p style="color:var(--text-dim); margin-bottom:12px;">
                    All verification data is saved locally in your browser. Use "Clear" to reset all data.
                    Data persists between sessions so you can verify large lists over multiple days.
                </p>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // State
        let addresses = [];
        let currentIndex = -1;
        // API key loaded at runtime via prompt ‚Äî never hardcoded
        let GMAP_TOKEN = sessionStorage.getItem('gmap_token') || '';
        function promptMapToken() {
            if (!GMAP_TOKEN) {
                const key = prompt('Enter your Google Maps API key:');
                if (key && key.trim()) {
                    GMAP_TOKEN = key.trim();
                    sessionStorage.setItem('gmap_token', GMAP_TOKEN);
                }
            }
            return !!GMAP_TOKEN;
        }

        // Bulk selection state
        let selectedIndices = new Set();

        // Undo state
        let undoStack = [];
        const MAX_UNDO = 20;

        // HTML escape for XSS prevention
        function escapeHtml(str) {
            if (!str) return '';
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        // Shared mailed tracker (same as Pool Scraper)
        let mailedTracker = JSON.parse(localStorage.getItem('poolscraper_mailed_v2') || '{}');

        function getMailedCount(address, city, zip) {
            const key = `${address}|${city}|${zip}`.toUpperCase();
            return mailedTracker[key] ? mailedTracker[key].count : 0;
        }

        function getMailedInfo(address, city, zip) {
            const key = `${address}|${city}|${zip}`.toUpperCase();
            return mailedTracker[key] || null;
        }

        // Campaign cache for performance
        let cachedCampaigns = null;
        let campaignCacheTime = 0;
        const CAMPAIGN_CACHE_TTL = 5000; // 5 second cache

        // Get campaign info (shared with Scraper) - with caching
        function getCampaignInfo(address, city, zip) {
            const now = Date.now();
            if (!cachedCampaigns || now - campaignCacheTime > CAMPAIGN_CACHE_TTL) {
                cachedCampaigns = JSON.parse(localStorage.getItem('poolscraper_campaigns') || '[]');
                campaignCacheTime = now;
            }
            for (const campaign of cachedCampaigns) {
                const found = (campaign.addresses || []).find(a =>
                    a.address?.toUpperCase() === address?.toUpperCase() &&
                    a.city?.toUpperCase() === city?.toUpperCase()
                );
                if (found) {
                    return {
                        name: campaign.name,
                        promoCode: campaign.promoCode,
                        date: campaign.dateCreated
                    };
                }
            }
            return null;
        }

        // Show address on Google Maps satellite
        function showOnMap(address) {
            if (!promptMapToken()) return;
            const query = encodeURIComponent(address);
            const mapUrl = `https://www.google.com/maps/embed/v1/place?key=${GMAP_TOKEN}&q=${query}&maptype=satellite&zoom=20`;
            document.getElementById('mapFrame').src = mapUrl;
        }

        function openAddModal() {
            document.getElementById('addStreet').value = '';
            document.getElementById('addCity').value = '';
            document.getElementById('addState').value = 'FL';
            document.getElementById('addZip').value = '';
            document.getElementById('addModalInfo').textContent = 'Manually add an address you found while browsing';
            document.getElementById('addModal').classList.add('show');
        }

        function openInGoogleMaps() {
            if (currentIndex >= 0 && addresses[currentIndex]) {
                const addr = addresses[currentIndex];
                window.open(`https://www.google.com/maps/search/${encodeURIComponent(addr.fullAddress)}/@28.5,-81.4,500m/data=!3m1!1e3`, '_blank', 'noopener,noreferrer');
            } else {
                window.open('https://www.google.com/maps/@28.5,-81.4,5000m/data=!3m1!1e3', '_blank', 'noopener,noreferrer');
            }
        }

        // Load CSV
        function loadCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                parseCSV(e.target.result, file.name);
                closeImportModal();
            };
            reader.readAsText(file);
        }

        function parseCSV(text, fileName) {
            const lines = text.trim().split('\n');
            const headers = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim());

            // Find column indices
            const nameIdx = headers.findIndex(h => h.includes('recipient') || h.includes('name'));
            const addrIdx = headers.findIndex(h => h === 'address' || h.includes('address'));
            const cityIdx = headers.findIndex(h => h.includes('city'));
            const stateIdx = headers.findIndex(h => h.includes('state'));
            const zipIdx = headers.findIndex(h => h.includes('zip'));
            const valueIdx = headers.findIndex(h => h.includes('value') && !h.includes('assessed'));
            const yearIdx = headers.findIndex(h => h.includes('year'));
            const ageIdx = headers.findIndex(h => h.includes('age'));

            // Load saved verification data
            const savedData = JSON.parse(localStorage.getItem('poolVerifierData') || '{}');

            addresses = [];
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const cols = parseCSVLine(lines[i]);

                const addr = {
                    id: i,
                    name: cols[nameIdx] || 'Current Resident',
                    address: cols[addrIdx] || '',
                    city: cols[cityIdx] || '',
                    state: cols[stateIdx] || 'FL',
                    zip: cols[zipIdx] || '',
                    value: cols[valueIdx] || '',
                    year: cols[yearIdx] || '',
                    age: cols[ageIdx] || '',
                    status: 'unreviewed',
                    verifiedAt: null
                };

                addr.fullAddress = `${addr.address}, ${addr.city}, ${addr.state} ${addr.zip}`;
                addr.key = addr.fullAddress.toUpperCase().replace(/[^A-Z0-9]/g, '');

                // Restore saved status
                if (savedData[addr.key]) {
                    addr.status = savedData[addr.key].status;
                    addr.verifiedAt = savedData[addr.key].verifiedAt;
                }

                addresses.push(addr);
            }

            // Check for duplicates (already mailed or verified)
            let mailedCount = 0;
            let verifiedCount = 0;
            addresses.forEach(a => {
                const mailKey = `${a.address}|${a.city}|${a.zip}`.toUpperCase();
                if (mailedTracker[mailKey]) {
                    mailedCount++;
                }
                if (a.status === 'verified' || a.status === 'no-pool') {
                    verifiedCount++;
                }
            });

            // Show warnings
            const warnings = [];
            if (mailedCount > 0) warnings.push(`${mailedCount} already mailed`);
            if (verifiedCount > 0) warnings.push(`${verifiedCount} already reviewed`);
            if (warnings.length > 0) {
                showToast(`‚ö†Ô∏è ${warnings.join(', ')}`, 'error');
            }

            document.getElementById('emptyMap').style.display = 'none';
            document.getElementById('currentPanel').style.display = 'block';
            document.getElementById('actionPanel').style.display = 'flex';

            renderList();
            updateStats();

            if (addresses.length > 0) {
                selectAddress(0);
            }

            showToast(`Loaded ${addresses.length} addresses from ${fileName}`, 'success');
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
                    else inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        // Render address list
        function renderList() {
            const filter = document.getElementById('statusFilter').value;
            const subdivFilter = document.getElementById('subdivisionFilter')?.value || 'all';
            const search = document.getElementById('searchInput').value.toLowerCase();
            const minValue = parseInt(document.getElementById('minValue')?.value) || 0;
            const maxValue = parseInt(document.getElementById('maxValue')?.value) || Infinity;

            // Build filtered list with original indices (O(n) instead of O(n¬≤))
            const filtered = [];
            for (let i = 0; i < addresses.length; i++) {
                const a = addresses[i];
                if (filter !== 'all' && filter !== 'unreviewed' && a.status !== filter) continue;
                if (filter === 'unreviewed' && a.status) continue;
                if (subdivFilter !== 'all' && (a.subdivision || '').toLowerCase() !== subdivFilter.toLowerCase()) continue;
                if (search && !a.fullAddress.toLowerCase().includes(search) && !a.name.toLowerCase().includes(search) && !(a.subdivision || '').toLowerCase().includes(search)) continue;

                // Value filter
                const value = parseFloat((a.value || '').replace(/[^0-9.]/g, '')) || 0;
                if (minValue > 0 && value < minValue * 1000) continue;
                if (maxValue < Infinity && value > maxValue * 1000) continue;

                filtered.push({ addr: a, idx: i });
            }

            const list = document.getElementById('addressList');
            if (filtered.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No addresses match filter</p></div>';
                return;
            }

            list.innerHTML = filtered.map(({ addr: a, idx }) => {
                const statusIcon = a.status === 'verified' ? '‚úÖ' : a.status === 'no-pool' ? '‚ùå' : a.status === 'pending' ? '‚è≥' : '‚¨ú';
                const mailCount = getMailedCount(a.address, a.city, a.zip);
                const mailBadge = mailCount > 0 ? `<span style="font-size:10px; color:var(--cyan); margin-left:4px;">üì¨${mailCount}x</span>` : '';
                const isSelected = selectedIndices.has(idx);
                return `
                    <div class="address-item ${a.status} ${idx === currentIndex ? 'active' : ''}" onclick="selectAddress(${idx})">
                        <input type="checkbox" class="bulk-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleSelect(${idx})" style="margin-right:6px;">
                        <div class="addr-num">#${idx + 1}</div>
                        <div class="addr-info">
                            <div class="addr-name">${escapeHtml(a.name)}${mailBadge}</div>
                            <div class="addr-street">${escapeHtml(a.address)}</div>
                            <div class="addr-city">${escapeHtml(a.city)}, ${escapeHtml(a.state)} ${escapeHtml(a.zip)}${a.subdivision ? ` <span style="color:var(--cyan);font-size:10px;">‚Ä¢ ${escapeHtml(a.subdivision)}</span>` : ''}</div>
                        </div>
                        <div class="addr-status">${statusIcon}</div>
                    </div>
                `;
            }).join('');

            updateBulkActionBar();
        }

        function filterList() {
            renderList();
        }

        // Select address
        function selectAddress(index) {
            if (index < 0 || index >= addresses.length) return;

            currentIndex = index;
            const addr = addresses[index];

            document.getElementById('currentName').textContent = addr.name;
            document.getElementById('currentAddress').textContent = addr.fullAddress;

            const statusIcon = addr.status === 'verified' ? '‚úÖ' : addr.status === 'no-pool' ? '‚ùå' : addr.status === 'pending' ? '‚è≥' : '‚¨ú';
            document.getElementById('currentStatus').textContent = statusIcon;

            // Show details
            let details = '';
            if (addr.value) details += `<div class="detail-item"><div class="detail-label">Value</div><div class="detail-value">${addr.value}</div></div>`;
            if (addr.year) details += `<div class="detail-item"><div class="detail-label">Year Built</div><div class="detail-value">${addr.year}</div></div>`;
            if (addr.age) details += `<div class="detail-item"><div class="detail-label">Pool Age</div><div class="detail-value">${addr.age}y</div></div>`;
            if (addr.verifiedAt) details += `<div class="detail-item"><div class="detail-label">Verified</div><div class="detail-value">${new Date(addr.verifiedAt).toLocaleDateString()}</div></div>`;

            // Show mailed info from shared tracker
            const mailInfo = getMailedInfo(addr.address, addr.city, addr.zip);
            if (mailInfo) {
                details += `<div class="detail-item"><div class="detail-label">Mailed</div><div class="detail-value" style="color:var(--cyan);">${mailInfo.count}x (last: ${mailInfo.lastMailed})</div></div>`;
            }

            // Show campaign info
            const campInfo = getCampaignInfo(addr.address, addr.city, addr.zip);
            if (campInfo) {
                details += `<div class="detail-item"><div class="detail-label">Campaign</div><div class="detail-value" style="color:var(--orange);">${campInfo.name}</div></div>`;
            }
            document.getElementById('currentDetails').innerHTML = details;

            renderList();
            updatePositionInfo();

            // Show on Google Maps satellite
            showOnMap(addr.fullAddress);
        }

        // Mark address
        function markAs(status) {
            if (currentIndex < 0 || currentIndex >= addresses.length) return;

            // Save for undo
            saveForUndo('status', currentIndex, addresses[currentIndex].status);

            addresses[currentIndex].status = status;
            addresses[currentIndex].verifiedAt = new Date().toISOString();

            saveData();
            updateStats();
            renderList();
            selectAddress(currentIndex);

            const msg = status === 'verified' ? '‚úÖ Marked as HAS POOL' : status === 'no-pool' ? '‚ùå Marked as NO POOL' : '‚è≥ Marked as PENDING';
            showToast(msg, status === 'verified' ? 'success' : '');

            // Auto-advance to next unreviewed
            const nextUnreviewed = addresses.findIndex((a, i) => i > currentIndex && a.status === 'unreviewed');
            if (nextUnreviewed !== -1) {
                setTimeout(() => selectAddress(nextUnreviewed), 300);
            }
        }

        function goToNext() {
            if (currentIndex < addresses.length - 1) {
                selectAddress(currentIndex + 1);
            }
        }

        function goToPrev() {
            if (currentIndex > 0) {
                selectAddress(currentIndex - 1);
            }
        }

        function jumpToAddress() {
            const input = document.getElementById('jumpToInput');
            const num = parseInt(input.value);
            if (num >= 1 && num <= addresses.length) {
                selectAddress(num - 1); // Convert to 0-based index
                input.value = '';
            } else {
                showToast(`Enter a number between 1 and ${addresses.length}`, 'error');
            }
        }

        function updatePositionInfo() {
            document.getElementById('positionInfo').textContent = `${currentIndex + 1} / ${addresses.length}`;
            document.getElementById('jumpToInput').max = addresses.length;
        }

        // Stats
        function updateStats() {
            const total = addresses.length;
            const verified = addresses.filter(a => a.status === 'verified').length;
            const noPool = addresses.filter(a => a.status === 'no-pool').length;
            const pending = addresses.filter(a => a.status === 'pending').length;
            const mailed = addresses.filter(a => getMailedCount(a.address, a.city, a.zip) > 0).length;

            document.getElementById('statTotal').textContent = total;
            document.getElementById('statVerified').textContent = verified;
            document.getElementById('statNoPool').textContent = noPool;
            document.getElementById('statPending').textContent = pending;
            document.getElementById('statMailed').textContent = mailed;

            // Update progress bar
            const reviewed = verified + noPool;
            const percent = total > 0 ? Math.round((reviewed / total) * 100) : 0;
            document.getElementById('progressText').textContent = `${reviewed} / ${total} reviewed`;
            document.getElementById('progressPercent').textContent = `${percent}%`;
            document.getElementById('progressFill').style.width = `${percent}%`;
        }

        // Save/Load data
        function saveData() {
            // Only save verification status (small data)
            // Full addresses are read directly from Scraper session
            const data = {};
            addresses.forEach(a => {
                if (a.status !== 'unreviewed') {
                    data[a.key] = { status: a.status, verifiedAt: a.verifiedAt };
                }
            });
            try {
                localStorage.setItem('poolVerifierData', JSON.stringify(data));
            } catch (e) {
                console.log('Could not save verification status:', e);
            }
        }

        // Auto-load from Scraper session on page load
        function loadSavedAddresses() {
            // Prefer filtered data (from "Send to Verifier"), fall back to full session
            if (localStorage.getItem('poolscraper_filtered') || localStorage.getItem('poolscraper_session')) {
                loadFromScraper();
                return true;
            }
            return false;
        }

        // Init on page load
        document.addEventListener('DOMContentLoaded', loadSavedAddresses);

        // Mark current address as mailed (shared with Scraper)
        function markAsMailed() {
            if (currentIndex < 0 || currentIndex >= addresses.length) return;

            const addr = addresses[currentIndex];
            const key = `${addr.address}|${addr.city}|${addr.zip}`.toUpperCase();
            const today = new Date().toISOString().slice(0, 10);

            if (mailedTracker[key]) {
                mailedTracker[key].count++;
                mailedTracker[key].lastMailed = today;
            } else {
                mailedTracker[key] = { count: 1, firstMailed: today, lastMailed: today };
            }

            localStorage.setItem('poolscraper_mailed_v2', JSON.stringify(mailedTracker));
            updateStats();
            renderList();
            selectAddress(currentIndex); // Refresh details

            showToast(`üì¨ Marked as mailed (${mailedTracker[key].count}x)`);
        }

        // ============== BULK SELECT FUNCTIONS ==============
        function toggleSelect(idx) {
            if (selectedIndices.has(idx)) {
                selectedIndices.delete(idx);
            } else {
                selectedIndices.add(idx);
            }
            updateBulkActionBar();
            renderList();
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAllCheckbox').checked;
            if (selectAll) {
                addresses.forEach((_, i) => selectedIndices.add(i));
            } else {
                selectedIndices.clear();
            }
            updateBulkActionBar();
            renderList();
        }

        function updateBulkActionBar() {
            const bar = document.getElementById('bulkActionBar');
            const count = selectedIndices.size;
            document.getElementById('bulkSelectedCount').textContent = `${count} selected`;
            if (count > 0) {
                bar.classList.add('show');
            } else {
                bar.classList.remove('show');
            }
        }

        function bulkMarkAs(status) {
            if (selectedIndices.size === 0) return;

            // Save for undo (bulk)
            const changes = [];
            selectedIndices.forEach(idx => {
                changes.push({ idx, oldStatus: addresses[idx].status });
                addresses[idx].status = status;
                addresses[idx].verifiedAt = new Date().toISOString();
            });
            undoStack.push({ type: 'bulk-status', changes });
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            document.getElementById('undoBtn').disabled = false;

            saveData();
            updateStats();
            clearBulkSelection();
            showToast(`${changes.length} addresses marked as ${status}`, 'success');
        }

        function bulkMarkAsMailed() {
            if (selectedIndices.size === 0) return;

            const today = new Date().toISOString().slice(0, 10);
            let count = 0;

            selectedIndices.forEach(idx => {
                const addr = addresses[idx];
                const key = `${addr.address}|${addr.city}|${addr.zip}`.toUpperCase();
                if (mailedTracker[key]) {
                    mailedTracker[key].count++;
                    mailedTracker[key].lastMailed = today;
                } else {
                    mailedTracker[key] = { count: 1, firstMailed: today, lastMailed: today };
                }
                count++;
            });

            localStorage.setItem('poolscraper_mailed_v2', JSON.stringify(mailedTracker));
            updateStats();
            clearBulkSelection();
            showToast(`üì¨ ${count} addresses marked as mailed`, 'success');
        }

        function clearBulkSelection() {
            selectedIndices.clear();
            document.getElementById('selectAllCheckbox').checked = false;
            updateBulkActionBar();
            renderList();
        }

        // ============== UNDO FUNCTION ==============
        function saveForUndo(type, idx, oldValue) {
            undoStack.push({ type, idx, oldValue });
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            document.getElementById('undoBtn').disabled = false;
        }

        function undoLastAction() {
            if (undoStack.length === 0) return;

            const action = undoStack.pop();

            if (action.type === 'status') {
                addresses[action.idx].status = action.oldValue || 'unreviewed';
                addresses[action.idx].verifiedAt = null;
            } else if (action.type === 'bulk-status') {
                action.changes.forEach(c => {
                    addresses[c.idx].status = c.oldStatus || 'unreviewed';
                    addresses[c.idx].verifiedAt = null;
                });
            }

            saveData();
            updateStats();
            renderList();
            showToast('‚Ü©Ô∏è Action undone');

            if (undoStack.length === 0) {
                document.getElementById('undoBtn').disabled = true;
            }
        }

        // ============== SKIP TO UNVERIFIED ==============
        function skipToUnverified() {
            const nextUnreviewed = addresses.findIndex((a, i) => !a.status || a.status === 'unreviewed');
            if (nextUnreviewed !== -1) {
                selectAddress(nextUnreviewed);
                showToast(`Jumped to #${nextUnreviewed + 1}`);
            } else {
                showToast('All addresses have been reviewed!', 'success');
            }
        }

        // Add new address
        function addNewAddress() {
            const name = document.getElementById('addName').value.trim() || 'Current Resident';
            const street = document.getElementById('addStreet').value.trim();
            const city = document.getElementById('addCity').value.trim();
            const state = document.getElementById('addState').value.trim() || 'FL';
            const zip = document.getElementById('addZip').value.trim();
            const status = document.getElementById('addStatus').value;

            if (!street) {
                showToast('Street address is required', 'error');
                return;
            }

            const addr = {
                id: addresses.length + 1,
                name: name,
                address: street,
                city: city,
                state: state,
                zip: zip,
                value: '',
                year: '',
                age: '',
                status: status,
                verifiedAt: new Date().toISOString()
            };
            addr.fullAddress = `${addr.address}, ${addr.city}, ${addr.state} ${addr.zip}`;
            addr.key = addr.fullAddress.toUpperCase().replace(/[^A-Z0-9]/g, '');

            addresses.push(addr);
            saveData();
            updateStats();
            renderList();
            selectAddress(addresses.length - 1);
            closeAddModal();

            showToast('Address added!', 'success');
        }

        function closeAddModal() {
            document.getElementById('addModal').classList.remove('show');
        }

        function showImportModal() {
            document.getElementById('importModal').classList.add('show');
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('show');
        }

        function showHelp() {
            document.getElementById('helpModal').classList.add('show');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('show');
        }

        function loadFromScraper() {
            // Try filtered data first (from "Send to Verifier" button), then fall back to full session
            let sessionData = localStorage.getItem('poolscraper_filtered');
            let isFiltered = true;

            if (!sessionData) {
                sessionData = localStorage.getItem('poolscraper_session');
                isFiltered = false;
            }

            if (!sessionData) {
                showToast('No Scraper data found. Process data in Pool Scraper first.', 'error');
                return;
            }

            let session;
            try {
                session = JSON.parse(sessionData);
            } catch (e) {
                showToast('Could not parse Scraper data', 'error');
                return;
            }

            const rawData = session.results || [];
            if (rawData.length === 0) {
                showToast('Scraper data is empty', 'error');
                return;
            }

            // Keep filtered data so re-syncs get the same updated list.
            // Scraper overwrites this key each time "Send to Verifier" is clicked.

            // Map from Scraper format to Verifier format
            const data = rawData.map(r => ({
                name: r.recipient || 'Current Resident',
                address: r.address || '',
                city: r.city || '',
                state: r.state || 'FL',
                zip: r.zipcode || '',
                subdivision: r.subdivision || '',
                value: r.propertyValue || '',
                year: r.yearBuilt || '',
                age: r.poolAge || '',
                saleDate: r.saleDate || ''
            }));

            // Load saved verification status (small data - just status per address)
            const savedData = JSON.parse(localStorage.getItem('poolVerifierData') || '{}');

            addresses = data.map((d, i) => {
                const addr = {
                    id: i + 1,
                    name: d.name || 'Current Resident',
                    address: d.address || '',
                    city: d.city || '',
                    state: d.state || 'FL',
                    zip: d.zip || '',
                    subdivision: expandSubdivisionAbbrevs(d.subdivision || ''),
                    value: d.value || '',
                    year: d.year || '',
                    age: d.age || '',
                    saleDate: d.saleDate || '',
                    status: 'unreviewed',
                    verifiedAt: null
                };
                addr.fullAddress = `${addr.address}, ${addr.city}, ${addr.state} ${addr.zip}`;
                addr.key = addr.fullAddress.toUpperCase().replace(/[^A-Z0-9]/g, '');

                // Restore saved status
                if (savedData[addr.key]) {
                    addr.status = savedData[addr.key].status;
                    addr.verifiedAt = savedData[addr.key].verifiedAt;
                }

                return addr;
            });

            document.getElementById('emptyMap').style.display = 'none';
            document.getElementById('currentPanel').style.display = 'block';
            document.getElementById('actionPanel').style.display = 'flex';

            renderList();
            updateStats();

            if (addresses.length > 0) {
                selectAddress(0);
            }

            // Populate subdivision filter dropdown
            populateSubdivisionFilter();

            const subdivs = [...new Set(addresses.map(a => a.subdivision).filter(s => s))];
            const sourceLabel = isFiltered ? 'filtered' : 'all';
            showToast(`Loaded ${addresses.length} ${sourceLabel} addresses (${subdivs.length} subdivisions)`, 'success');
        }

        // Export
        function exportVerified() {
            if (addresses.length === 0) {
                showToast('No addresses to export', 'error');
                return;
            }
            updateExportCount();
            document.getElementById('exportModal').classList.add('show');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('show');
        }

        function updateExportCount() {
            const filter = document.getElementById('exportFilter').value;
            let count = 0;
            if (filter === 'verified') count = addresses.filter(a => a.status === 'verified').length;
            else if (filter === 'all-reviewed') count = addresses.filter(a => a.status === 'verified' || a.status === 'no-pool').length;
            else count = addresses.length;
            document.getElementById('exportCount').textContent = `${count} addresses will be exported`;
        }

        function doExport() {
            const filter = document.getElementById('exportFilter').value;
            const isRouteFormat = document.getElementById('expRouteFormat')?.checked;
            let toExport = [];
            if (filter === 'verified') toExport = addresses.filter(a => a.status === 'verified');
            else if (filter === 'all-reviewed') toExport = addresses.filter(a => a.status === 'verified' || a.status === 'no-pool');
            else toExport = addresses;

            if (toExport.length === 0) {
                showToast('No addresses match the filter', 'error');
                return;
            }

            // Route format: sort by zip/city/street and add stop numbers
            if (isRouteFormat) {
                toExport = [...toExport].sort((a, b) => {
                    const zipA = (a.zip || '').substring(0, 5);
                    const zipB = (b.zip || '').substring(0, 5);
                    if (zipA !== zipB) return zipA.localeCompare(zipB);
                    if (a.city !== b.city) return (a.city || '').localeCompare(b.city || '');
                    const streetA = (a.address || '').replace(/^\d+\s*/, '');
                    const streetB = (b.address || '').replace(/^\d+\s*/, '');
                    if (streetA !== streetB) return streetA.localeCompare(streetB);
                    const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0');
                    const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0');
                    return numA - numB;
                });
            }

            // Build header based on selected columns - FIXED ORDER: Recipient, Company, Address, City, State, Zipcode first
            const cols = [];
            // Add stop number for route format
            if (isRouteFormat) cols.push({ key: 'stop', header: 'Stop #' });
            // Core columns in fixed order
            if (document.getElementById('expRecipient').checked) cols.push({ key: 'name', header: 'Recipient' });
            if (document.getElementById('expCompany').checked) cols.push({ key: 'company', header: 'Company' });
            if (document.getElementById('expAddress').checked) cols.push({ key: 'address', header: 'Address' });
            if (document.getElementById('expCity').checked) cols.push({ key: 'city', header: 'City' });
            if (document.getElementById('expState').checked) cols.push({ key: 'state', header: 'State' });
            if (document.getElementById('expZip').checked) cols.push({ key: 'zip', header: 'Zipcode' });
            // Additional columns
            if (document.getElementById('expSubdivision')?.checked) cols.push({ key: 'subdivision', header: 'Subdivision' });
            if (document.getElementById('expValue').checked) cols.push({ key: 'value', header: 'PropertyValue' });
            if (document.getElementById('expYear').checked) cols.push({ key: 'year', header: 'YearBuilt' });
            if (document.getElementById('expAge').checked) cols.push({ key: 'age', header: 'PoolAge' });
            if (document.getElementById('expStatus')?.checked) cols.push({ key: 'status', header: 'Status' });
            if (document.getElementById('expSaleDate')?.checked) cols.push({ key: 'saleDate', header: 'SaleDate' });
            if (document.getElementById('expVerifiedAt').checked) cols.push({ key: 'verifiedAt', header: 'VerifiedDate' });

            if (cols.length === 0) {
                showToast('Select at least one column', 'error');
                return;
            }

            let csv = cols.map(c => c.header).join(',') + '\n';
            toExport.forEach((a, idx) => {
                const row = cols.map(c => {
                    let val = a[c.key] || '';
                    // Handle special cases
                    if (c.key === 'stop') val = idx + 1;
                    if (c.key === 'company') val = a.company || '';
                    if (c.key === 'name') val = a.name || 'Current Resident';
                    if (c.key === 'verifiedAt' && val) val = new Date(val).toLocaleDateString();
                    if (c.key === 'status') val = a.status === 'verified' ? 'Has Pool' : (a.status === 'no-pool' ? 'No Pool' : 'Pending');
                    return `"${String(val).replace(/"/g, '""')}"`;
                });
                csv += row.join(',') + '\n';
            });

            const filterName = filter === 'verified' ? 'Verified' : filter === 'all-reviewed' ? 'Reviewed' : 'All';
            const fileName = isRouteFormat ? `Pool_Route_${new Date().toISOString().slice(0,10)}.csv` : `Pool_${filterName}_${new Date().toISOString().slice(0,10)}.csv`;
            downloadFile(csv, fileName);
            showToast(`Exported ${toExport.length} addresses${isRouteFormat ? ' (route sorted)' : ''}`, 'success');
            closeExportModal();
        }

        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Route functions
        function sortByRoute() {
            if (addresses.length === 0) { showToast('No addresses to sort', 'error'); return; }

            // Sort by subdivision first (walking clusters), then street, then house number
            addresses.sort((a, b) => {
                // 1. Group by subdivision (walking distance clusters)
                const subdivA = (a.subdivision || '').toLowerCase();
                const subdivB = (b.subdivision || '').toLowerCase();
                if (subdivA !== subdivB) return subdivA.localeCompare(subdivB);

                // 2. Within subdivision, group by zip
                const zipA = (a.zip || '').substring(0, 5);
                const zipB = (b.zip || '').substring(0, 5);
                if (zipA !== zipB) return zipA.localeCompare(zipB);

                // 3. Then by street name
                const streetA = (a.address || '').replace(/^\d+\s*/, '').toLowerCase();
                const streetB = (b.address || '').replace(/^\d+\s*/, '').toLowerCase();
                if (streetA !== streetB) return streetA.localeCompare(streetB);

                // 4. Then by house number (sequential for walking)
                const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0');
                const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0');
                return numA - numB;
            });

            // Reset to first address and update display
            currentIndex = 0;
            renderList();
            selectAddress(0);
            saveData();
            const subdivCount = [...new Set(addresses.map(a => a.subdivision).filter(s => s))].length;
            showToast(`Sorted by subdivision route (${subdivCount} subdivisions)`, 'success');
        }

        function openGoogleMapsRoute() {
            // Get verified addresses for route
            const verified = addresses.filter(a => a.status === 'verified');
            const toRoute = verified.length > 0 ? verified : addresses;

            if (toRoute.length === 0) {
                showToast('No addresses for route', 'error');
                return;
            }

            // Google Maps supports up to 10 waypoints
            const maxStops = 10;
            const routeAddresses = toRoute.slice(0, maxStops).map(a => {
                return encodeURIComponent(`${a.address}, ${a.city}, ${a.state} ${a.zip}`);
            });

            if (routeAddresses.length === 0) {
                showToast('No valid addresses', 'error');
                return;
            }

            // Build Google Maps directions URL
            const mapsUrl = 'https://www.google.com/maps/dir/' + routeAddresses.join('/');
            window.open(mapsUrl, '_blank', 'noopener,noreferrer');
            showToast(`Opened ${routeAddresses.length} stops in Google Maps`, 'success');
        }

        // Populate subdivision filter dropdown
        function populateSubdivisionFilter() {
            const select = document.getElementById('subdivisionFilter');
            if (!select) return;

            const subdivs = [...new Set(addresses.map(a => a.subdivision).filter(s => s && s.trim()))].sort();

            select.innerHTML = '<option value="all">All Subdivisions (' + addresses.length + ')</option>';
            subdivs.forEach(s => {
                const count = addresses.filter(a => a.subdivision === s).length;
                select.innerHTML += `<option value="${escapeHtml(s)}">${escapeHtml(s)} (${count})</option>`;
            });
        }

        // Plot walking route for selected subdivision
        function plotSubdivisionRoute() {
            const subdivFilter = document.getElementById('subdivisionFilter')?.value || 'all';

            // Get addresses for selected subdivision
            let toRoute = addresses;
            if (subdivFilter !== 'all') {
                toRoute = addresses.filter(a => (a.subdivision || '').toLowerCase() === subdivFilter.toLowerCase());
            }

            if (toRoute.length === 0) {
                showToast('No addresses in selected subdivision', 'error');
                return;
            }

            // Sort by walking order: street name, then house number
            toRoute = [...toRoute].sort((a, b) => {
                const streetA = (a.address || '').replace(/^\d+\s*/, '').toLowerCase();
                const streetB = (b.address || '').replace(/^\d+\s*/, '').toLowerCase();
                if (streetA !== streetB) return streetA.localeCompare(streetB);
                const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0');
                const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0');
                return numA - numB;
            });

            const subdivName = subdivFilter === 'all' ? 'all addresses' : subdivFilter;

            // If more than 10 stops, show options
            if (toRoute.length > 10) {
                const choice = confirm(`${toRoute.length} stops in ${subdivName}.\n\nOK = View all as pins on map\nCancel = Open in batches of 10 (walking directions)`);

                if (choice) {
                    // View all as pins - no waypoint limit
                    openAllAsPins(toRoute, subdivName);
                } else {
                    // Open in batches of 10 with walking directions
                    openInBatches(toRoute, subdivName);
                }
            } else {
                // 10 or fewer - open as walking route
                openWalkingRoute(toRoute, subdivName);
            }
        }

        // Open all addresses as pins on Google Maps (no limit)
        function openAllAsPins(toRoute, label) {
            // Create numbered list for reference
            let stopList = toRoute.map((a, i) => `${i+1}. ${a.address}`).join('\n');

            // Copy to clipboard
            navigator.clipboard.writeText(stopList).then(() => {
                showToast('Stop list copied to clipboard!', 'success');
            }).catch(() => {});

            // Open Google Maps centered on first address with search for the area
            const centerAddr = toRoute[0];
            const searchQuery = encodeURIComponent(`${centerAddr.city}, ${centerAddr.state} ${centerAddr.zip}`);
            const mapsUrl = `https://www.google.com/maps/search/${searchQuery}/@${encodeURIComponent(centerAddr.address + ', ' + centerAddr.city)},17z`;
            window.open(mapsUrl, '_blank', 'noopener,noreferrer');

            // Show the stop list in an alert for reference
            alert(`üìç ${toRoute.length} STOPS (walking order):\n\n${stopList}\n\n‚úì List copied to clipboard\n‚úì Map opened to area`);
        }

        // Open walking directions in batches of 10
        function openInBatches(toRoute, label) {
            const batchSize = 10;
            const batches = Math.ceil(toRoute.length / batchSize);

            for (let i = 0; i < batches; i++) {
                const batch = toRoute.slice(i * batchSize, (i + 1) * batchSize);
                setTimeout(() => {
                    openWalkingRoute(batch, `${label} (Batch ${i + 1}/${batches})`);
                }, i * 1000); // Stagger window opens
            }

            showToast(`Opening ${batches} route batches for ${toRoute.length} stops`, 'success');
        }

        // Open walking route for up to 10 addresses
        function openWalkingRoute(toRoute, label) {
            const routeAddresses = toRoute.map(a => {
                return encodeURIComponent(`${a.address}, ${a.city}, ${a.state} ${a.zip}`);
            });

            let mapsUrl;
            if (routeAddresses.length === 1) {
                mapsUrl = `https://www.google.com/maps/search/${routeAddresses[0]}`;
            } else if (routeAddresses.length === 2) {
                mapsUrl = `https://www.google.com/maps/dir/?api=1&travelmode=walking&origin=${routeAddresses[0]}&destination=${routeAddresses[1]}`;
            } else {
                const waypoints = routeAddresses.slice(1, -1).join('|');
                mapsUrl = `https://www.google.com/maps/dir/?api=1&travelmode=walking&origin=${routeAddresses[0]}&destination=${routeAddresses[routeAddresses.length-1]}&waypoints=${waypoints}`;
            }

            window.open(mapsUrl, '_blank', 'noopener,noreferrer');
            showToast(`Walking route: ${routeAddresses.length} stops - ${label}`, 'success');
        }

        function exportRouteCSV() {
            if (addresses.length === 0) { showToast('No addresses to export', 'error'); return; }

            // Sort by route first
            const sorted = [...addresses].sort((a, b) => {
                const zipA = (a.zip || '').substring(0, 5);
                const zipB = (b.zip || '').substring(0, 5);
                if (zipA !== zipB) return zipA.localeCompare(zipB);
                if (a.city !== b.city) return (a.city || '').localeCompare(b.city || '');
                const streetA = (a.address || '').replace(/^\d+\s*/, '');
                const streetB = (b.address || '').replace(/^\d+\s*/, '');
                if (streetA !== streetB) return streetA.localeCompare(streetB);
                const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0');
                const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0');
                return numA - numB;
            });

            // Generate CSV with stop numbers
            const headers = ['Stop #', 'Name', 'Address', 'City', 'State', 'Zip', 'Status', 'Value'];
            const rows = sorted.map((a, i) => {
                return [
                    i + 1,
                    `"${(a.name || 'Current Resident').replace(/"/g, '""')}"`,
                    `"${(a.address || '').replace(/"/g, '""')}"`,
                    `"${(a.city || '').replace(/"/g, '""')}"`,
                    `"${(a.state || '').replace(/"/g, '""')}"`,
                    `"${(a.zip || '').replace(/"/g, '""')}"`,
                    `"${(a.status || 'pending').replace(/"/g, '""')}"`,
                    `"${(a.value || '').replace(/"/g, '""')}"`
                ].join(',');
            });

            const csv = headers.join(',') + '\n' + rows.join('\n');
            downloadFile(csv, `Route_${new Date().toISOString().slice(0,10)}.csv`);
            showToast(`Exported ${sorted.length} addresses with route order`, 'success');
        }

        // Expand common Florida subdivision abbreviations
        function expandSubdivisionAbbrevs(str) {
            if (!str) return '';
            const abbrevs = {
                'Brs ': "Bear's ", 'Brs$': "Bear's",
                'Lk ': 'Lake ', 'Lk$': 'Lake',
                'Lks ': 'Lakes ',
                'Est ': 'Estates ', 'Est$': 'Estates',
                'Ests ': 'Estates ',
                'Hts ': 'Heights ', 'Hts$': 'Heights',
                'Hgts ': 'Heights ',
                'Spgs ': 'Springs ', 'Spgs$': 'Springs',
                'Sprgs ': 'Springs ',
                'Crk ': 'Creek ', 'Crk$': 'Creek',
                'Vlg ': 'Village ', 'Vlg$': 'Village',
                'Vllg ': 'Village ',
                'Mnr ': 'Manor ', 'Mnr$': 'Manor',
                'Pnt ': 'Point ', 'Pt ': 'Point ',
                'Gdns ': 'Gardens ', 'Gdn ': 'Garden ',
                'Grvs ': 'Groves ', 'Grv ': 'Grove ',
                'Plc ': 'Place ',
                'Cir ': 'Circle ',
                'Ter ': 'Terrace ', 'Trce ': 'Trace ',
                'Xing ': 'Crossing ',
                'Ldg ': 'Landing ', 'Lndg ': 'Landing ',
                'Rdg ': 'Ridge ', 'Rdg$': 'Ridge',
                'Vly ': 'Valley ', 'Vw ': 'View ',
                'Hls ': 'Hills ', 'Hl ': 'Hill ',
                'Rnch ': 'Ranch ', 'Rch ': 'Ranch ',
                'Plns ': 'Plains ', 'Pln ': 'Plain ',
                'Mdws ': 'Meadows ', 'Mdw ': 'Meadow ',
                'Oks ': 'Oaks ', 'Wds ': 'Woods ',
                'Frst ': 'Forest ', 'Fst ': 'Forest ',
                'Pk ': 'Park ', 'Prk ': 'Park ',
                'Ctr ': 'Center ', 'Cntr ': 'Center ',
                'Shrs ': 'Shores ', 'Bch ': 'Beach ',
                'Isl ': 'Isle ', 'Twn ': 'Town ',
                'Cmns ': 'Commons ', 'Comm ': 'Commons ',
                'Res ': 'Reserve ', 'Rsrv ': 'Reserve ', 'Rsv ': 'Reserve ',
                'Plnt ': 'Plantation ', 'Plntn ': 'Plantation ',
                'Addn ': 'Addition ', 'Add ': 'Addition ',
                'Rplt ': 'Replat ', 'Rp ': 'Replat ',
                'Ut ': 'Unit ', 'Un ': 'Unit ',
                'Sec ': 'Section ', 'Blk ': 'Block ',
                'Tr ': 'Tract ', 'Lot ': 'Lot '
            };

            let result = str;
            for (const [abbr, full] of Object.entries(abbrevs)) {
                if (abbr.endsWith('$')) {
                    // End of string match
                    const pattern = abbr.slice(0, -1);
                    const regex = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'gi');
                    result = result.replace(regex, full.trim());
                } else {
                    const regex = new RegExp(abbr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                    result = result.replace(regex, full);
                }
            }
            return result.trim();
        }

        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show ' + type;
            setTimeout(() => toast.className = 'toast', 3000);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Escape closes any open modal
            if (e.key === 'Escape') {
                closeHelp();
                closeAddModal();
                closeImportModal();
                closeExportModal();
                return;
            }

            // ? shows help (works even when no addresses loaded)
            if (e.key === '?' || (e.shiftKey && e.key === '/')) {
                showHelp();
                return;
            }

            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (addresses.length === 0) return;

            switch(e.key.toLowerCase()) {
                case 'y': markAs('verified'); break;
                case 'n': markAs('no-pool'); break;
                case 'p': markAs('pending'); break;
                case 'm': markAsMailed(); break;
                case 'arrowright': goToNext(); break;
                case 'arrowleft': goToPrev(); break;
                case 'g': openInGoogleMaps(); break;
                case 's': skipToUnverified(); break;
                case 'u': undoLastAction(); break;
                case 'z': if (e.ctrlKey || e.metaKey) { e.preventDefault(); undoLastAction(); } break;
            }
        });

        // Drag and drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', e => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.csv')) {
                loadCSV({ target: { files: [file] } });
            }
        });

        // Clear all data
        function clearAllData() {
            if (!confirm('Clear all verification data? This cannot be undone.')) return;
            localStorage.removeItem('poolVerifierData');
            addresses = [];
            currentIndex = -1;
            document.getElementById('addressList').innerHTML = '<div class="empty-state"><p>Load a CSV to begin</p></div>';
            document.getElementById('currentPanel').style.display = 'none';
            document.getElementById('actionPanel').style.display = 'none';
            document.getElementById('emptyMap').style.display = 'flex';
            document.getElementById('mapFrame').src = '';
            updateStats();
            showToast('All data cleared', 'success');
        }
    </script>
</body>
</html>
