<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AquaDesk - Identifier</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        /* Hide duplicate nav when inside AquaDesk dashboard iframe */
        .in-iframe .header .logo,
        .in-iframe .header .nav-tabs { display: none !important; }
        :root {
            --bg: #0a0a0f;
            --bg-card: #12121a;
            --bg-hover: #1a1a24;
            --border: #2a2a35;
            --text: #e4e4e7;
            --text-dim: #71717a;
            --accent: #06b6d4;
            --green: #22c55e;
            --orange: #f59e0b;
            --red: #ef4444;
            --purple: #8b5cf6;
        }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); font-size: 13px; height: 100vh; display: flex; flex-direction: column; }

        /* Header */
        .header { display: flex; align-items: center; padding: 8px 16px; background: var(--bg-card); border-bottom: 1px solid var(--border); gap: 12px; }
        .logo { font-weight: 700; font-size: 15px; color: var(--text); display: flex; align-items: center; gap: 8px; }
        .logo span { color: var(--accent); }
        .nav-tabs { display: flex; gap: 4px; margin-left: 16px; }
        .nav-tab { padding: 6px 14px; border-radius: 6px; cursor: pointer; color: var(--text-dim); font-size: 12px; font-weight: 500; text-decoration: none; display: flex; align-items: center; gap: 6px; background: var(--bg-hover); transition: all 0.15s; }
        .nav-tab:hover { background: var(--accent); color: #000; }
        .nav-tab.active { background: var(--accent); color: #000; }
        .header-controls { display: flex; gap: 8px; margin-left: auto; align-items: center; }
        .btn { padding: 8px 14px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.15s; }
        .btn-primary { background: var(--accent); color: #000; }
        .btn-primary:hover { filter: brightness(1.1); }
        .btn-success { background: var(--green); color: #000; }
        .btn-danger { background: var(--red); color: white; }
        .btn-secondary { background: var(--bg-hover); color: var(--text); border: 1px solid var(--border); }
        .btn-lg { padding: 12px 24px; font-size: 14px; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Main Layout */
        .main { flex: 1; display: flex; overflow: hidden; }

        /* Sidebar */
        .sidebar { width: 380px; background: var(--bg-card); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }

        /* Stats Bar */
        .stats-bar { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; padding: 12px; border-bottom: 1px solid var(--border); }
        .stat { text-align: center; padding: 8px; background: var(--bg); border-radius: 6px; }
        .stat-value { font-size: 20px; font-weight: 700; }
        .stat-value.cyan { color: var(--accent); }
        .stat-value.green { color: var(--green); }
        .stat-value.red { color: var(--red); }
        .stat-value.orange { color: var(--orange); }
        .stat-label { font-size: 9px; color: var(--text-dim); text-transform: uppercase; margin-top: 2px; }

        /* Filter Bar */
        .filter-bar { display: flex; gap: 6px; padding: 10px 12px; border-bottom: 1px solid var(--border); align-items: center; flex-wrap: wrap; }
        .filter-bar select { padding: 6px 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 11px; }
        .filter-bar input { padding: 6px 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 11px; flex: 1; min-width: 120px; }

        /* Address List */
        .address-list { flex: 1; overflow-y: auto; }
        .address-item { padding: 10px 12px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; display: flex; gap: 10px; align-items: flex-start; }
        .address-item:hover { background: var(--bg-hover); }
        .address-item.active { background: var(--accent); color: #000; }
        .address-item.active .addr-city, .address-item.active .addr-status { color: #000; }
        .address-item.verified { border-left: 3px solid var(--green); }
        .address-item.no-pool { border-left: 3px solid var(--red); }
        .address-item.pending { border-left: 3px solid var(--orange); }
        .addr-num { font-size: 10px; color: var(--text-dim); min-width: 30px; }
        .address-item.active .addr-num { color: #000; }
        .addr-info { flex: 1; min-width: 0; }
        .addr-name { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .addr-street { font-size: 11px; color: var(--text-dim); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .address-item.active .addr-street { color: rgba(0,0,0,0.7); }
        .addr-city { font-size: 10px; color: var(--text-dim); }
        .addr-status { font-size: 18px; min-width: 24px; text-align: center; }

        /* Map Container */
        .map-area { flex: 1; display: flex; flex-direction: column; }

        /* Current Address Panel */
        .current-panel { padding: 12px 16px; background: var(--bg-card); border-bottom: 1px solid var(--border); }
        .current-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px; }
        .current-name { font-size: 18px; font-weight: 700; color: var(--accent); }
        .current-address { color: var(--text-dim); font-size: 13px; }
        .current-details { display: flex; gap: 16px; margin-top: 10px; flex-wrap: wrap; }
        .detail-item { display: flex; flex-direction: column; }
        .detail-label { font-size: 9px; color: var(--text-dim); text-transform: uppercase; }
        .detail-value { font-size: 14px; font-weight: 600; }

        /* Action Panel */
        .action-panel { padding: 12px 16px; background: var(--bg-card); border-bottom: 1px solid var(--border); display: flex; gap: 10px; align-items: center; }
        .action-buttons { display: flex; gap: 8px; }
        .btn-pool { background: var(--green); color: #000; padding: 10px 20px; font-size: 14px; }
        .btn-pool:hover { filter: brightness(1.1); }
        .btn-nopool { background: var(--red); color: white; padding: 10px 20px; font-size: 14px; }
        .btn-nopool:hover { filter: brightness(1.1); }
        .btn-pending { background: var(--orange); color: #000; padding: 10px 20px; font-size: 14px; }
        .nav-buttons { display: flex; gap: 6px; margin-left: auto; }
        .keyboard-hints { font-size: 10px; color: var(--text-dim); margin-left: 12px; }
        .keyboard-hints kbd { background: var(--bg); padding: 2px 6px; border-radius: 3px; color: var(--accent); }

        /* Map */
        #map { flex: 1; background: #1a1a2e; position: relative; min-height: 0; overflow: hidden; }
        #mapFrame { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }


        /* Modal */
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 2000; }
        .modal.show { display: flex; }
        .modal-content { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; width: 450px; max-width: 90%; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .modal-header h3 { font-size: 16px; }
        .modal-close { background: none; border: none; color: var(--text-dim); font-size: 24px; cursor: pointer; }
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; font-size: 11px; color: var(--text-dim); text-transform: uppercase; margin-bottom: 4px; }
        .form-group input, .form-group select { width: 100%; padding: 8px 10px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); font-size: 13px; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .modal-actions { display: flex; gap: 10px; margin-top: 20px; }
        .modal-actions .btn { flex: 1; }

        /* Toast */
        .toast { position: fixed; bottom: 20px; right: 20px; background: var(--bg-card); border: 1px solid var(--border); padding: 12px 20px; border-radius: 8px; z-index: 3000; transform: translateY(100px); opacity: 0; transition: all 0.3s; }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { border-color: var(--green); }
        .toast.error { border-color: var(--red); }

        /* Empty State */
        .empty-state { flex: 1; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 16px; color: var(--text-dim); }
        .empty-state h2 { color: var(--text); font-size: 18px; }
        .upload-zone { border: 2px dashed var(--border); border-radius: 12px; padding: 40px 60px; text-align: center; cursor: pointer; transition: all 0.2s; }
        .upload-zone:hover { border-color: var(--accent); background: rgba(6, 182, 212, 0.05); }

        /* History Panel */
        .history-panel { max-height: 200px; overflow-y: auto; margin-top: 12px; }
        .history-item { font-size: 11px; padding: 6px 0; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; }
        .history-time { color: var(--text-dim); }

        input[type="file"] { display: none; }

        /* Export dropdown */
        .export-dropdown-wrap { position: relative; }
        .export-dropdown-menu {
            position: absolute; top: 100%; right: 0;
            background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px;
            min-width: 200px; z-index: 1000; box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: none; padding: 6px 0;
        }
        .export-dropdown-menu.show { display: block; }
        .export-dropdown-menu button {
            display: flex; align-items: center; gap: 8px; width: 100%;
            padding: 10px 16px; background: none; border: none;
            color: var(--text); font-size: 12px; cursor: pointer; text-align: left;
        }
        .export-dropdown-menu button:hover { background: var(--bg-hover); }

        /* Progress Bar */
        .progress-bar-container { padding: 8px 12px; border-bottom: 1px solid var(--border); }
        .progress-bar-label { display: flex; justify-content: space-between; font-size: 11px; color: var(--text-dim); margin-bottom: 4px; }
        .progress-bar { height: 8px; background: var(--bg); border-radius: 4px; overflow: hidden; }
        .progress-bar-fill { height: 100%; background: linear-gradient(90deg, var(--green), var(--accent)); transition: width 0.3s ease; border-radius: 4px; }

        /* Bulk Select */
        .bulk-checkbox { width: 16px; height: 16px; cursor: pointer; accent-color: var(--accent); }
        .bulk-action-bar { padding: 8px 12px; background: var(--accent); color: #000; display: flex; align-items: center; gap: 10px; font-size: 12px; font-weight: 600; }
        .bulk-action-bar.show { display: flex; }
        .bulk-action-bar button { background: rgba(0,0,0,0.2); border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; color: #000; font-weight: 600; }
        .bulk-action-bar button:hover { background: rgba(0,0,0,0.3); }

        /* Value Filter */
        .value-filter { display: flex; align-items: center; gap: 4px; }
        .value-filter input { width: 70px !important; flex: none !important; min-width: auto !important; }
        .value-filter span { font-size: 10px; color: var(--text-dim); }
    </style>
</head>
<body>
    <script>if(window.self!==window.top)document.documentElement.classList.add('in-iframe');</script>
    <div class="header">
        <div class="logo">üíß AquaDesk</div>
        <div class="nav-tabs">
            <a href="pool-scraper.html" class="nav-tab">üìã Scraper</a>
            <a href="#" class="nav-tab active">üîç Identifier</a>
            <a href="postcard.html" class="nav-tab">üé® Postcard</a>
        </div>
        <div class="header-controls">
            <button class="btn btn-secondary" onclick="openAddModal()">‚ûï Add</button>
            <button class="btn btn-primary" onclick="loadFromScraper()">üì• Load from Scraper</button>
            <div class="export-dropdown-wrap">
                <button class="btn btn-primary" onclick="toggleExportMenu()">üì§ Export ‚ñæ</button>
                <div class="export-dropdown-menu" id="exportDropdownMenu">
                    <button onclick="exportVerified(); closeExportMenu();">üì§ Export Verified CSV</button>
                    <button onclick="quickVistaPrint(); closeExportMenu();" style="color:var(--green); font-weight:700;">‚ö° VistaPrint</button>
                    <button onclick="showImportModal(); closeExportMenu();">üì• Import CSV</button>
                    <button onclick="sortByRoute(); openGoogleMapsRoute(); closeExportMenu();">üó∫Ô∏è Route</button>
                </div>
            </div>
            <button class="btn btn-secondary" style="color:var(--red);" onclick="clearAllData()">üóëÔ∏è</button>
            <button class="btn btn-secondary" onclick="showHelp()">‚ùì</button>
        </div>
    </div>


    <div class="main">
        <div class="sidebar">
            <div class="stats-bar" style="grid-template-columns: repeat(5, 1fr);">
                <div class="stat">
                    <div class="stat-value cyan" id="statTotal">0</div>
                    <div class="stat-label">Total</div>
                </div>
                <div class="stat">
                    <div class="stat-value green" id="statVerified">0</div>
                    <div class="stat-label">Has Pool</div>
                </div>
                <div class="stat">
                    <div class="stat-value red" id="statNoPool">0</div>
                    <div class="stat-label">No Pool</div>
                </div>
                <div class="stat">
                    <div class="stat-value orange" id="statPending">0</div>
                    <div class="stat-label">Pending</div>
                </div>
                <div class="stat">
                    <div class="stat-value" style="color:var(--cyan);" id="statMailed">0</div>
                    <div class="stat-label">Mailed</div>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="progress-bar-container">
                <div class="progress-bar-label">
                    <span id="progressText">0 / 0 verified</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="progressFill" style="width: 0%;"></div>
                </div>
            </div>

            <!-- Bulk Action Bar -->
            <div class="bulk-action-bar" id="bulkActionBar">
                <input type="checkbox" class="bulk-checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()" title="Select All">
                <span id="bulkSelectedCount">0 selected</span>
                <button onclick="bulkMarkAs('verified')">‚úÖ Has Pool</button>
                <button onclick="bulkMarkAs('no-pool')">‚ùå No Pool</button>
                <button onclick="bulkMarkAsMailed()">üì¨ Mark Mailed</button>
                <button onclick="clearBulkSelection()" style="margin-left:auto;">‚úï Clear</button>
            </div>

            <div class="filter-bar">
                <select id="statusFilter" onchange="filterList()">
                    <option value="all">All Status</option>
                    <option value="unreviewed">Unreviewed</option>
                    <option value="verified">‚úÖ Has Pool</option>
                    <option value="no-pool">‚ùå No Pool</option>
                    <option value="pending">‚è≥ Pending</option>
                </select>
                <select id="subdivisionFilter" onchange="filterList()" style="max-width:180px;">
                    <option value="all">All Subdivisions</option>
                </select>
                <input type="text" id="searchInput" placeholder="Search..." oninput="filterList()">
                <button class="btn" style="background:#10b981; color:#000; padding:6px 10px;" onclick="plotSubdivisionRoute()" title="Plot walking route for selected subdivision">üö∂ Walk Route</button>
            </div>
            <div class="filter-bar" style="border-bottom:none; padding-top:0;">
                <span style="font-size:11px; color:var(--text-dim);">Go to #</span>
                <input type="number" id="jumpToInput" min="1" placeholder="1" style="width:70px;" onkeydown="if(event.key==='Enter')jumpToAddress()">
                <button class="btn btn-secondary" onclick="jumpToAddress()" style="padding:6px 10px;">Go</button>
                <button class="btn" style="background:var(--orange); color:#000; padding:6px 10px;" onclick="skipToUnverified()" title="Jump to next unreviewed">‚è≠Ô∏è Skip</button>
                <button class="btn btn-secondary" id="undoBtn" onclick="undoLastAction()" style="padding:6px 10px;" disabled title="Undo last action">‚Ü©Ô∏è Undo</button>
                <span style="font-size:11px; color:var(--text-dim); margin-left:auto;" id="positionInfo">0 / 0</span>
            </div>

            <div class="address-list" id="addressList">
                <div class="empty-state">
                    <p>Load a CSV to begin</p>
                </div>
            </div>
        </div>

        <div class="map-area">
            <div class="current-panel" id="currentPanel" style="display:none;">
                <div class="current-header">
                    <div>
                        <div class="current-name" id="currentName">-</div>
                        <div class="current-address" id="currentAddress">-</div>
                    </div>
                    <div id="currentStatus" style="font-size:24px;">‚¨ú</div>
                </div>
                <div class="current-details" id="currentDetails"></div>
            </div>

            <div class="action-panel" id="actionPanel" style="display:none;">
                <div class="action-buttons">
                    <button class="btn btn-pool" onclick="markAs('verified')">‚úÖ Has Pool</button>
                    <button class="btn btn-nopool" onclick="markAs('no-pool')">‚ùå No Pool</button>
                    <button class="btn btn-pending" onclick="markAs('pending')">‚è≥ Pending</button>
                    <button class="btn" style="background:var(--cyan); color:#000;" onclick="markAsMailed()">üì¨ Mailed</button>
                </div>
                <div class="nav-buttons">
                    <button class="btn btn-secondary" onclick="goToPrev()">‚óÄ Prev</button>
                    <button class="btn btn-secondary" onclick="goToNext()">Next ‚ñ∂</button>
                    <button class="btn btn-secondary" onclick="openInGoogleMaps()" title="Open in Google Maps">üó∫Ô∏è</button>
                </div>
                <div class="keyboard-hints">
                    <kbd>Y</kbd> Pool <kbd>N</kbd> No <kbd>P</kbd> Pending <kbd>M</kbd> Mailed <kbd>S</kbd> Skip <kbd>U</kbd> Undo <kbd>‚Üê</kbd><kbd>‚Üí</kbd> Nav <kbd>G</kbd> Maps
                </div>
            </div>

            <div id="map">
                <iframe id="mapFrame" allowfullscreen loading="lazy"></iframe>
            </div>

            <div class="empty-state" id="emptyMap">
                <div class="upload-zone" onclick="document.getElementById('fileInput').click()">
                    <h2>üìÅ Drop CSV or Click to Upload</h2>
                    <p>Load addresses from Pool Scraper to verify</p>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".csv" onchange="loadCSV(event)">

    <!-- Add Address Modal -->
    <div class="modal" id="addModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üè† Add New Address</h3>
                <button class="modal-close" onclick="closeAddModal()">&times;</button>
            </div>
            <div class="form-group">
                <label>Recipient Name</label>
                <input type="text" id="addName" value="Current Resident">
            </div>
            <div class="form-group">
                <label>Street Address</label>
                <input type="text" id="addStreet" placeholder="123 Main St">
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>City</label>
                    <input type="text" id="addCity">
                </div>
                <div class="form-group">
                    <label>State</label>
                    <input type="text" id="addState" value="FL">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Zip Code</label>
                    <input type="text" id="addZip">
                </div>
                <div class="form-group">
                    <label>Status</label>
                    <select id="addStatus">
                        <option value="verified">‚úÖ Has Pool</option>
                        <option value="pending">‚è≥ Pending</option>
                    </select>
                </div>
            </div>
            <div id="addModalInfo" style="font-size:11px; color:var(--text-dim); margin-top:8px;"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeAddModal()">Cancel</button>
                <button class="btn btn-success" onclick="addNewAddress()">Add Address</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üì§ Export Verified Addresses</h3>
                <button class="modal-close" onclick="closeExportModal()">&times;</button>
            </div>
            <p style="font-size:12px; color:var(--text-dim); margin-bottom:12px;">Select columns to include (exported in order shown):</p>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expRecipient" checked> 1. Recipient
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expCompany" checked> 2. Company
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expAddress" checked> 3. Address <span style="font-size:9px; color:var(--text-dim);">(auto: mail if diff, prop if same)</span>
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expCity" checked> 4. City
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expState" checked> 5. State
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expZip" checked> 6. Zipcode
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px; border-top:1px solid var(--border); padding-top:8px; grid-column:span 2;">
                    <strong style="color:var(--text-dim); font-size:11px;">Additional columns:</strong>
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expValue"> Property Value
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expYear"> Year Built
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expAge"> Pool Age
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expVerifiedAt"> Verified Date
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expStatus"> Status
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expSubdivision"> Subdivision
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expSaleDate"> Sale Date
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expPropertyAddress"> Property Address
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expMailingAddress"> Mailing Address
                </label>
                <label style="display:flex; align-items:center; gap:8px; font-size:13px;">
                    <input type="checkbox" id="expAddressSource"> Address Source (Prop/Mail)
                </label>
            </div>
            <div style="margin-top:16px;">
                <label style="font-size:11px; color:var(--text-dim);">Export which addresses:</label>
                <select id="exportFilter" style="width:100%; margin-top:4px; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--bg); color:var(--text);" onchange="updateExportCount()">
                    <option value="verified">‚úÖ Has Pool only</option>
                    <option value="all-reviewed">All reviewed (Pool + No Pool)</option>
                    <option value="all">All addresses</option>
                </select>
            </div>
            <div style="margin-top:12px;">
                <label style="display:flex; align-items:center; gap:8px; font-size:12px;">
                    <input type="checkbox" id="expRouteFormat"> Export as Route CSV (for GPS/mapping)
                </label>
            </div>
            <div style="margin-top:12px;">
                <label style="display:flex; align-items:center; gap:8px; font-size:12px;">
                    <input type="checkbox" id="expPerSubdiv" onchange="togglePerSubdiv()"> Export each subdivision as separate file
                </label>
            </div>
            <div id="perSubdivPreview" style="display:none; margin-top:8px; padding:8px; background:var(--surface); border-radius:6px; border:1px solid var(--border); max-height:120px; overflow-y:auto;">
            </div>
            <div id="singleFileNameWrap" style="margin-top:12px;">
                <label style="font-size:11px; color:var(--text-dim);">File name:</label>
                <input type="text" id="expFileName" placeholder="e.g. River_Walk_Verified" style="width:100%; margin-top:4px; padding:8px; border:1px solid var(--border); border-radius:4px; background:var(--bg); color:var(--text); font-size:13px;">
                <span style="font-size:10px; color:var(--text-dim);">.csv will be added automatically</span>
            </div>
            <div id="exportCount" style="margin-top:12px; font-size:12px; color:var(--accent);"></div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeExportModal()">Cancel</button>
                <button class="btn btn-success" onclick="doExport()">Export CSV</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üì• Import Addresses</h3>
                <button class="modal-close" onclick="closeImportModal()">&times;</button>
            </div>
            <div class="upload-zone" onclick="document.getElementById('fileInput').click()" style="padding:30px;">
                <h2>üìÅ Select CSV File</h2>
                <p>VistaPrint format or Pool Scraper export</p>
            </div>
            <div style="margin-top:16px; text-align:center; color:var(--text-dim); font-size:12px;">
                Or drag & drop a file anywhere on the page
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal" id="helpModal">
        <div class="modal-content" style="width:600px; max-height:85vh; overflow-y:auto;">
            <div class="modal-header">
                <h3>‚ùì Pool Identifier Pro Help</h3>
                <button class="modal-close" onclick="closeHelp()">&times;</button>
            </div>
            <div style="font-size:12px; line-height:1.6;">
                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üéØ Purpose</h4>
                <p style="color:var(--text-dim); margin-bottom:12px;">
                    Pool Identifier Pro lets you visually confirm whether properties have pools using Google Maps satellite imagery.
                    This eliminates wasted postcards sent to homes without pools.
                </p>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üì• Loading Data</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Load from Scraper:</strong> Click to import addresses synced from Pool Scraper Pro (recommended workflow)</li>
                    <li><strong>Import CSV:</strong> Upload any CSV with address columns (Recipient, Address, City, State, Zip)</li>
                    <li><strong>Drag & Drop:</strong> Drop a CSV file anywhere on the page</li>
                    <li><strong>Add Address:</strong> Manually add individual addresses</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üîç Verification Process</h4>
                <ol style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li>Select an address from the list on the left</li>
                    <li>Examine the satellite view for a pool (blue rectangle in backyard)</li>
                    <li>Mark as: <span style="color:var(--green);">‚úÖ Has Pool</span>, <span style="color:var(--red);">‚ùå No Pool</span>, or <span style="color:var(--orange);">‚è≥ Pending</span></li>
                    <li>Tool auto-advances to next unreviewed address</li>
                </ol>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">‚å®Ô∏è Keyboard Shortcuts</h4>
                <table style="width:100%; border-collapse:collapse; margin-bottom:12px;">
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">Y</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Mark as Has Pool (Yes)</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">N</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Mark as No Pool</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">P</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Mark as Pending (unclear imagery)</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">‚Üê</kbd> <kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">‚Üí</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Navigate previous / next address</td>
                    </tr>
                    <tr style="border-bottom:1px solid var(--border);">
                        <td style="padding:6px;"><kbd style="background:var(--bg); padding:2px 8px; border-radius:3px; color:var(--accent);">G</kbd></td>
                        <td style="padding:6px; color:var(--text-dim);">Open current address in Google Maps</td>
                    </tr>
                </table>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üîÑ Status Colors</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><span style="color:var(--green);">Green border</span> = Verified (has pool)</li>
                    <li><span style="color:var(--red);">Red border</span> = No Pool</li>
                    <li><span style="color:var(--orange);">Orange border</span> = Pending review</li>
                    <li>No border = Unreviewed</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üîó Integration with Pool Scraper</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Import:</strong> Use "Load from Scraper" after clicking "Sync to Identifier" in Pool Scraper</li>
                    <li><strong>No-Pool Sync:</strong> Addresses marked ‚ùå No Pool are automatically excluded from Pool Scraper exports when "Exclude No Pool" is checked</li>
                    <li>Both tools share verification status via browser storage</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üì§ Exporting</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Export Verified:</strong> Download CSV of addresses with confirmed pools</li>
                    <li>Choose which columns to include (Recipient, Address, City, State, Zip, etc.)</li>
                    <li>Filter options: Has Pool only, All reviewed, or All addresses</li>
                    <li>VistaPrint-compatible format for postcard printing</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üìä Filtering & Navigation</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li><strong>Status Filter:</strong> Show All, Unreviewed, Has Pool, No Pool, or Pending</li>
                    <li><strong>Search:</strong> Filter by address or name</li>
                    <li><strong>Go to #:</strong> Jump directly to a specific address number</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üí° Tips</h4>
                <ul style="color:var(--text-dim); margin-left:20px; margin-bottom:12px;">
                    <li>Pools appear as blue rectangles, usually in the backyard</li>
                    <li>Use "Pending" for addresses with tree cover or unclear imagery</li>
                    <li>Press <kbd style="background:var(--bg); padding:2px 6px; border-radius:3px; color:var(--accent);">G</kbd> to open in Google Maps for street view or better zoom</li>
                    <li>Your progress is auto-saved - close and return anytime</li>
                    <li>Filter to "Unreviewed" to focus on addresses that need verification</li>
                </ul>

                <h4 style="color:var(--accent); margin:16px 0 8px; font-size:14px;">üíæ Data Storage</h4>
                <p style="color:var(--text-dim); margin-bottom:12px;">
                    All verification data is saved locally in your browser. Use "Clear" to reset all data.
                    Data persists between sessions so you can verify large lists over multiple days.
                </p>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Constants
        const STATUS = Object.freeze({ VERIFIED: 'verified', NO_POOL: 'no-pool', PENDING: 'pending' });
        const MAX_ROUTE_STOPS = 10;

        // State
        let addresses = [];
        let currentIndex = -1;
        // API key persisted in localStorage ‚Äî never hardcoded
        let GMAP_TOKEN = localStorage.getItem('gmap_token') || '';
        function promptMapToken() {
            if (!GMAP_TOKEN) {
                const key = prompt('Enter your Google Maps API key:');
                if (key && key.trim()) {
                    const trimmed = key.trim();
                    if (!/^[A-Za-z0-9_-]{20,60}$/.test(trimmed)) {
                        showToast('Invalid API key format', 'error');
                        return false;
                    }
                    GMAP_TOKEN = trimmed;
                    localStorage.setItem('gmap_token', GMAP_TOKEN);
                }
            }
            return !!GMAP_TOKEN;
        }

        // Resolve which address to use for mailing: mailing if different, property if same/blank
        function resolveMailAddress(a) {
            const prop = (a.propertyAddress || '').trim();
            const mail = (a.mailingAddress || '').trim();
            if (!mail || mail.toUpperCase().replace(/[^A-Z0-9]/g, '') === prop.toUpperCase().replace(/[^A-Z0-9]/g, '')) {
                return { address: prop || a.address, source: 'Property' };
            }
            return { address: mail, source: 'Mailing' };
        }

        // Bulk selection state
        let selectedIndices = new Set();

        // Undo state
        let undoStack = [];
        const MAX_UNDO = 20;

        // HTML escape for XSS prevention
        function escapeHtml(str) {
            if (!str) return '';
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        // Shared mailed tracker (same as Pool Scraper)
        let mailedTracker = JSON.parse(localStorage.getItem('poolscraper_mailed_v2') || '{}');

        function getMailedCount(address, city, zip) {
            const key = `${address}|${city}|${zip}`.toUpperCase();
            return mailedTracker[key] ? mailedTracker[key].count : 0;
        }

        function getMailedInfo(address, city, zip) {
            const key = `${address}|${city}|${zip}`.toUpperCase();
            return mailedTracker[key] || null;
        }

        // Campaign cache for performance
        let cachedCampaigns = null;
        let campaignCacheTime = 0;
        const CAMPAIGN_CACHE_TTL = 5000; // 5 second cache

        // Get campaign info (shared with Scraper) - with caching
        function getCampaignInfo(address, city, zip) {
            const now = Date.now();
            if (!cachedCampaigns || now - campaignCacheTime > CAMPAIGN_CACHE_TTL) {
                cachedCampaigns = JSON.parse(localStorage.getItem('poolscraper_campaigns') || '[]');
                campaignCacheTime = now;
            }
            for (const campaign of cachedCampaigns) {
                const found = (campaign.addresses || []).find(a =>
                    a.address?.toUpperCase() === address?.toUpperCase() &&
                    a.city?.toUpperCase() === city?.toUpperCase()
                );
                if (found) {
                    return {
                        name: campaign.name,
                        promoCode: campaign.promoCode,
                        date: campaign.dateCreated
                    };
                }
            }
            return null;
        }

        // Show address on Google Maps satellite
        function showOnMap(address) {
            if (!promptMapToken()) return;
            const query = encodeURIComponent(address);
            const mapUrl = `https://www.google.com/maps/embed/v1/place?key=${GMAP_TOKEN}&q=${query}&maptype=satellite&zoom=20`;
            document.getElementById('mapFrame').src = mapUrl;
        }

        function openAddModal() {
            document.getElementById('addStreet').value = '';
            document.getElementById('addCity').value = '';
            document.getElementById('addState').value = 'FL';
            document.getElementById('addZip').value = '';
            document.getElementById('addModalInfo').textContent = 'Manually add an address you found while browsing';
            document.getElementById('addModal').classList.add('show');
        }

        function openInGoogleMaps() {
            if (currentIndex >= 0 && addresses[currentIndex]) {
                const addr = addresses[currentIndex];
                window.open(`https://www.google.com/maps/search/${encodeURIComponent(addr.fullAddress)}/@${addr.fullAddress ? '' : '28.5,-81.4,'}500m/data=!3m1!1e3`, '_blank', 'noopener,noreferrer');
            } else {
                // Use first loaded address as fallback center, default to Orlando if no data
                const fallback = addresses.length > 0 && addresses[0].fullAddress
                    ? `search/${encodeURIComponent(addresses[0].fullAddress)}`
                    : '@28.5,-81.4,5000m';
                window.open(`https://www.google.com/maps/${fallback}/data=!3m1!1e3`, '_blank', 'noopener,noreferrer');
            }
        }

        // Load CSV
        function loadCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                parseCSV(e.target.result, file.name);
                closeImportModal();
            };
            reader.readAsText(file);
        }

        function parseCSV(text, fileName) {
            const lines = text.trim().split('\n');
            const headers = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim());

            // Find column indices
            const nameIdx = headers.findIndex(h => h.includes('recipient') || h.includes('name'));
            const addrIdx = headers.findIndex(h => h === 'address' || h.includes('address'));
            const cityIdx = headers.findIndex(h => h.includes('city'));
            const stateIdx = headers.findIndex(h => h.includes('state'));
            const zipIdx = headers.findIndex(h => h.includes('zip'));
            const valueIdx = headers.findIndex(h => h.includes('value') && !h.includes('assessed'));
            const yearIdx = headers.findIndex(h => h.includes('year'));
            const ageIdx = headers.findIndex(h => h.includes('age'));
            const propAddrIdx = headers.findIndex(h => h.includes('property address') || h.includes('prop addr') || h.includes('propertyaddress'));
            const mailAddrIdx = headers.findIndex(h => h.includes('mailing address') || h.includes('mail addr') || h.includes('mailingaddress'));

            // Load saved verification data
            const savedData = JSON.parse(localStorage.getItem('poolVerifierData') || '{}');

            addresses = [];
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const cols = parseCSVLine(lines[i]);

                const addr = {
                    id: i,
                    name: cols[nameIdx] || 'Current Resident',
                    address: cols[addrIdx] || '',
                    city: cols[cityIdx] || '',
                    state: cols[stateIdx] || 'FL',
                    zip: cols[zipIdx] || '',
                    value: cols[valueIdx] || '',
                    year: cols[yearIdx] || '',
                    age: cols[ageIdx] || '',
                    propertyAddress: propAddrIdx >= 0 ? (cols[propAddrIdx] || '') : '',
                    mailingAddress: mailAddrIdx >= 0 ? (cols[mailAddrIdx] || '') : '',
                    status: 'unreviewed',
                    verifiedAt: null
                };

                addr.fullAddress = `${addr.address}, ${addr.city}, ${addr.state} ${addr.zip}`;
                addr.key = addr.fullAddress.toUpperCase().replace(/[^A-Z0-9]/g, '');

                // Restore saved status
                if (savedData[addr.key]) {
                    addr.status = savedData[addr.key].status ?? 'unreviewed';
                    addr.verifiedAt = savedData[addr.key].verifiedAt ?? null;
                }

                addresses.push(addr);
            }

            // Check for duplicates (already mailed or verified)
            let mailedCount = 0;
            let verifiedCount = 0;
            addresses.forEach(a => {
                const mailKey = `${a.address}|${a.city}|${a.zip}`.toUpperCase();
                if (mailedTracker[mailKey]) {
                    mailedCount++;
                }
                if (a.status === STATUS.VERIFIED || a.status === STATUS.NO_POOL) {
                    verifiedCount++;
                }
            });

            // Show warnings
            const warnings = [];
            if (mailedCount > 0) warnings.push(`${mailedCount} already mailed`);
            if (verifiedCount > 0) warnings.push(`${verifiedCount} already reviewed`);
            if (warnings.length > 0) {
                showToast(`‚ö†Ô∏è ${warnings.join(', ')}`, 'error');
            }

            document.getElementById('emptyMap').style.display = 'none';
            document.getElementById('currentPanel').style.display = 'block';
            document.getElementById('actionPanel').style.display = 'flex';

            renderList();
            updateStats();

            if (addresses.length > 0) {
                selectAddress(0);
            }

            showToast(`Loaded ${addresses.length} addresses from ${fileName}`, 'success');
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
                    else inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        // Render address list
        let _saveTimer = null;
        function renderList() {
            // Auto-save session (debounced)
            clearTimeout(_saveTimer);
            _saveTimer = setTimeout(saveVerifierSession, 1000);
            const filter = document.getElementById('statusFilter').value;
            const subdivFilter = document.getElementById('subdivisionFilter')?.value || 'all';
            const search = document.getElementById('searchInput').value.toLowerCase();
            const minValue = parseInt(document.getElementById('minValue')?.value) || 0;
            const maxValue = parseInt(document.getElementById('maxValue')?.value) || Infinity;

            // Build filtered list with original indices (O(n) instead of O(n¬≤))
            const filtered = [];
            for (let i = 0; i < addresses.length; i++) {
                const a = addresses[i];
                if (filter !== 'all' && filter !== 'unreviewed' && a.status !== filter) continue;
                if (filter === 'unreviewed' && a.status) continue;
                if (subdivFilter !== 'all' && (a.subdivision || '').toLowerCase() !== subdivFilter.toLowerCase()) continue;
                if (search && !a.fullAddress.toLowerCase().includes(search) && !a.name.toLowerCase().includes(search) && !(a.subdivision || '').toLowerCase().includes(search)) continue;

                // Value filter
                const value = parseFloat((a.value || '').replace(/[^0-9.]/g, '')) || 0;
                if (minValue > 0 && value < minValue * 1000) continue;
                if (maxValue < Infinity && value > maxValue * 1000) continue;

                filtered.push({ addr: a, idx: i });
            }

            const list = document.getElementById('addressList');
            if (filtered.length === 0) {
                list.innerHTML = '<div class="empty-state"><p>No addresses match filter</p></div>';
                return;
            }

            list.innerHTML = filtered.map(({ addr: a, idx }) => {
                const statusIcon = a.status === STATUS.VERIFIED ? '‚úÖ' : a.status === STATUS.NO_POOL ? '‚ùå' : a.status === STATUS.PENDING ? '‚è≥' : '‚¨ú';
                const mailCount = getMailedCount(a.address, a.city, a.zip);
                const mailBadge = mailCount > 0 ? `<span style="font-size:10px; color:var(--cyan); margin-left:4px;">üì¨${mailCount}x</span>` : '';
                const isSelected = selectedIndices.has(idx);
                return `
                    <div class="address-item ${a.status} ${idx === currentIndex ? 'active' : ''}" onclick="selectAddress(${idx})">
                        <input type="checkbox" class="bulk-checkbox" ${isSelected ? 'checked' : ''} onclick="event.stopPropagation(); toggleSelect(${idx})" style="margin-right:6px;">
                        <div class="addr-num">#${idx + 1}</div>
                        <div class="addr-info">
                            <div class="addr-name">${escapeHtml(a.name)}${mailBadge}</div>
                            <div class="addr-street">${escapeHtml(a.address)}${(a.propertyAddress || a.mailingAddress) ? ` <span style="font-size:9px; padding:1px 4px; border-radius:3px; background:${resolveMailAddress(a).source === 'Mailing' ? 'var(--orange)' : 'var(--cyan)'}; color:#000; font-weight:600;">${resolveMailAddress(a).source === 'Mailing' ? '‚úâ Mail' : 'üè† Prop'}</span>` : ''}</div>
                            <div class="addr-city">${escapeHtml(a.city)}, ${escapeHtml(a.state)} ${escapeHtml(a.zip)}${a.subdivision ? ` <span style="color:var(--cyan);font-size:10px;">‚Ä¢ ${escapeHtml(a.subdivision)}</span>` : ''}</div>
                        </div>
                        <div class="addr-status">${statusIcon}</div>
                    </div>
                `;
            }).join('');

            updateBulkActionBar();
        }

        function filterList() {
            renderList();
        }

        // Select address
        function selectAddress(index) {
            if (index < 0 || index >= addresses.length) return;

            currentIndex = index;
            const addr = addresses[index];

            document.getElementById('currentName').textContent = addr.name;
            document.getElementById('currentAddress').textContent = addr.fullAddress;

            const statusIcon = addr.status === STATUS.VERIFIED ? '‚úÖ' : addr.status === STATUS.NO_POOL ? '‚ùå' : addr.status === STATUS.PENDING ? '‚è≥' : '‚¨ú';
            document.getElementById('currentStatus').textContent = statusIcon;

            // Show details
            let details = '';
            const resolved = resolveMailAddress(addr);
            if (addr.propertyAddress) details += `<div class="detail-item"><div class="detail-label">üè† Property</div><div class="detail-value" style="color:${resolved.source === 'Property' ? 'var(--cyan)' : 'var(--text-dim)'};${resolved.source === 'Property' ? 'font-weight:bold;' : ''}">${escapeHtml(addr.propertyAddress)}${resolved.source === 'Property' ? ' ‚Üê export' : ''}</div></div>`;
            if (addr.mailingAddress) details += `<div class="detail-item"><div class="detail-label">‚úâ Mailing</div><div class="detail-value" style="color:${resolved.source === 'Mailing' ? 'var(--orange)' : 'var(--text-dim)'};${resolved.source === 'Mailing' ? 'font-weight:bold;' : ''}">${escapeHtml(addr.mailingAddress)}${resolved.source === 'Mailing' ? ' ‚Üê export' : ''}</div></div>`;
            if (addr.value) details += `<div class="detail-item"><div class="detail-label">Value</div><div class="detail-value">${addr.value}</div></div>`;
            if (addr.year) details += `<div class="detail-item"><div class="detail-label">Year Built</div><div class="detail-value">${addr.year}</div></div>`;
            if (addr.age) details += `<div class="detail-item"><div class="detail-label">Pool Age</div><div class="detail-value">${addr.age}y</div></div>`;
            if (addr.verifiedAt) details += `<div class="detail-item"><div class="detail-label">Verified</div><div class="detail-value">${new Date(addr.verifiedAt).toLocaleDateString()}</div></div>`;

            // Show mailed info from shared tracker
            const mailInfo = getMailedInfo(addr.address, addr.city, addr.zip);
            if (mailInfo) {
                details += `<div class="detail-item"><div class="detail-label">Mailed</div><div class="detail-value" style="color:var(--cyan);">${mailInfo.count}x (last: ${mailInfo.lastMailed})</div></div>`;
            }

            // Show campaign info
            const campInfo = getCampaignInfo(addr.address, addr.city, addr.zip);
            if (campInfo) {
                details += `<div class="detail-item"><div class="detail-label">Campaign</div><div class="detail-value" style="color:var(--orange);">${campInfo.name}</div></div>`;
            }
            document.getElementById('currentDetails').innerHTML = details;

            renderList();
            updatePositionInfo();

            // Show on Google Maps satellite
            showOnMap(addr.fullAddress);
        }

        // Mark address
        function markAs(status) {
            if (currentIndex < 0 || currentIndex >= addresses.length) return;

            // Save for undo
            saveForUndo('status', currentIndex, addresses[currentIndex].status);

            addresses[currentIndex].status = status;
            addresses[currentIndex].verifiedAt = new Date().toISOString();

            saveData();
            updateStats();
            renderList();
            selectAddress(currentIndex);

            const msg = status === STATUS.VERIFIED ? '‚úÖ Marked as HAS POOL' : status === STATUS.NO_POOL ? '‚ùå Marked as NO POOL' : '‚è≥ Marked as PENDING';
            showToast(msg, status === STATUS.VERIFIED ? 'success' : '');

            // Auto-advance to next unreviewed
            const nextUnreviewed = addresses.findIndex((a, i) => i > currentIndex && a.status === 'unreviewed');
            if (nextUnreviewed !== -1) {
                setTimeout(() => selectAddress(nextUnreviewed), 300);
            }
        }

        function goToNext() {
            if (currentIndex < addresses.length - 1) {
                selectAddress(currentIndex + 1);
            }
        }

        function goToPrev() {
            if (currentIndex > 0) {
                selectAddress(currentIndex - 1);
            }
        }

        function jumpToAddress() {
            const input = document.getElementById('jumpToInput');
            const num = parseInt(input.value);
            if (num >= 1 && num <= addresses.length) {
                selectAddress(num - 1); // Convert to 0-based index
                input.value = '';
            } else {
                showToast(`Enter a number between 1 and ${addresses.length}`, 'error');
            }
        }

        function updatePositionInfo() {
            document.getElementById('positionInfo').textContent = `${currentIndex + 1} / ${addresses.length}`;
            document.getElementById('jumpToInput').max = addresses.length;
        }

        // Stats
        function updateStats() {
            const total = addresses.length;
            const verified = addresses.filter(a => a.status === STATUS.VERIFIED).length;
            const noPool = addresses.filter(a => a.status === STATUS.NO_POOL).length;
            const pending = addresses.filter(a => a.status === STATUS.PENDING).length;
            const mailed = addresses.filter(a => getMailedCount(a.address, a.city, a.zip) > 0).length;

            document.getElementById('statTotal').textContent = total;
            document.getElementById('statVerified').textContent = verified;
            document.getElementById('statNoPool').textContent = noPool;
            document.getElementById('statPending').textContent = pending;
            document.getElementById('statMailed').textContent = mailed;

            // Update progress bar
            const reviewed = verified + noPool;
            const percent = total > 0 ? Math.round((reviewed / total) * 100) : 0;
            document.getElementById('progressText').textContent = `${reviewed} / ${total} reviewed`;
            document.getElementById('progressPercent').textContent = `${percent}%`;
            document.getElementById('progressFill').style.width = `${percent}%`;
        }

        // Save/Load data
        function saveData() {
            // Only save verification status (small data)
            // Full addresses are read directly from Scraper session
            const data = {};
            addresses.forEach(a => {
                if (a.status !== 'unreviewed') {
                    data[a.key] = { status: a.status, verifiedAt: a.verifiedAt };
                }
            });
            try {
                localStorage.setItem('poolVerifierData', JSON.stringify(data));
            } catch (e) {
                if (e.name === 'QuotaExceededError') showToast('Storage full ‚Äî verification data not saved. Clear old data.', 'error');
                else console.warn('[verifier] saveData failed:', e.message);
            }
        }

        // Auto-load from Scraper session on page load
        function loadSavedAddresses() {
            // Check if verifier already has a working set saved
            const savedSession = localStorage.getItem('poolVerifier_session');
            if (savedSession) {
                try {
                    const session = JSON.parse(savedSession);
                    if (Array.isArray(session.addresses) && session.addresses.length > 0 && session.addresses.length <= 50000) {
                        addresses = session.addresses;
                        document.getElementById('emptyMap').style.display = 'none';
                        document.getElementById('currentPanel').style.display = 'block';
                        document.getElementById('actionPanel').style.display = 'flex';
                        renderList();
                        updateStats();
                        populateSubdivisionFilter();
                        if (addresses.length > 0) selectAddress(0);
                        showToast(`Restored ${addresses.length} addresses from last session`);
                        // Check if scraper has newer data
                        const scraperData = localStorage.getItem('poolscraper_transfer');
                        if (scraperData) {
                            const scraper = JSON.parse(scraperData);
                            if (scraper.timestamp > (session.timestamp || '')) {
                                showToast('New data available from Scraper ‚Äî click "Load from Scraper" to update', 'info');
                            }
                        }
                        return true;
                    }
                } catch (e) { console.warn('[verifier] session parse:', e.message); }
            }
            // No saved session ‚Äî only load explicitly sent data
            if (localStorage.getItem('poolscraper_transfer') || localStorage.getItem('poolscraper_filtered')) {
                loadFromScraper();
                return true;
            }
            return false;
        }

        // Save verifier working session
        function saveVerifierSession() {
            if (addresses.length === 0) return; // Never overwrite with empty data
            try {
                localStorage.setItem('poolVerifier_session', JSON.stringify({
                    addresses: addresses,
                    timestamp: new Date().toISOString()
                }));
            } catch (e) {
                if (e.name === 'QuotaExceededError') showToast('Storage full ‚Äî session not saved', 'error');
                else console.warn('[verifier] session save:', e.message);
            }
        }

        // Init on page load
        document.addEventListener('DOMContentLoaded', loadSavedAddresses);

        // Detect when Scraper writes new data (critical for iframe dashboard)
        window.addEventListener('storage', function(e) {
            if (e.key === 'poolscraper_transfer' && e.newValue) {
                showToast('New data from Scraper ‚Äî click "Load from Scraper" to update');
            }
            // Sync mailedTracker across tabs (prevents phantom state)
            if (e.key === 'poolscraper_mailed_v2' && e.newValue) {
                try { mailedTracker = JSON.parse(e.newValue); } catch (err) { console.warn('[verifier] mailed sync:', err.message); }
            }
        });

        // Save session on tab switch / page close
        window.addEventListener('beforeunload', saveVerifierSession);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) saveVerifierSession();
        });

        // Mark current address as mailed (shared with Scraper)
        function markAsMailed() {
            if (currentIndex < 0 || currentIndex >= addresses.length) return;

            const addr = addresses[currentIndex];
            const key = `${addr.address}|${addr.city}|${addr.zip}`.toUpperCase();
            const today = new Date().toISOString().slice(0, 10);

            // Re-read from localStorage to prevent race condition with other tabs
            try { mailedTracker = JSON.parse(localStorage.getItem('poolscraper_mailed_v2') || '{}'); } catch (_) {}

            if (mailedTracker[key]) {
                mailedTracker[key].count++;
                mailedTracker[key].lastMailed = today;
            } else {
                mailedTracker[key] = { count: 1, firstMailed: today, lastMailed: today };
            }

            try {
                localStorage.setItem('poolscraper_mailed_v2', JSON.stringify(mailedTracker));
            } catch (e) {
                if (e.name === 'QuotaExceededError') showToast('Storage full ‚Äî mailed status not saved', 'error');
            }
            updateStats();
            renderList();
            selectAddress(currentIndex); // Refresh details

            showToast(`üì¨ Marked as mailed (${mailedTracker[key].count}x)`);
        }

        // ============== BULK SELECT FUNCTIONS ==============
        function toggleSelect(idx) {
            if (selectedIndices.has(idx)) {
                selectedIndices.delete(idx);
            } else {
                selectedIndices.add(idx);
            }
            updateBulkActionBar();
            renderList();
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAllCheckbox').checked;
            if (selectAll) {
                addresses.forEach((_, i) => selectedIndices.add(i));
            } else {
                selectedIndices.clear();
            }
            updateBulkActionBar();
            renderList();
        }

        function updateBulkActionBar() {
            const bar = document.getElementById('bulkActionBar');
            const count = selectedIndices.size;
            document.getElementById('bulkSelectedCount').textContent = `${count} selected`;
            if (count > 0) {
                bar.classList.add('show');
            } else {
                bar.classList.remove('show');
            }
        }

        function bulkMarkAs(status) {
            if (selectedIndices.size === 0) return;

            // Save for undo (bulk)
            const changes = [];
            selectedIndices.forEach(idx => {
                changes.push({ idx, oldStatus: addresses[idx].status });
                addresses[idx].status = status;
                addresses[idx].verifiedAt = new Date().toISOString();
            });
            undoStack.push({ type: 'bulk-status', changes });
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            document.getElementById('undoBtn').disabled = false;

            saveData();
            updateStats();
            clearBulkSelection();
            showToast(`${changes.length} addresses marked as ${status}`, 'success');
        }

        function bulkMarkAsMailed() {
            if (selectedIndices.size === 0) return;

            const today = new Date().toISOString().slice(0, 10);
            let count = 0;

            // Re-read to prevent race condition with other tabs
            try { mailedTracker = JSON.parse(localStorage.getItem('poolscraper_mailed_v2') || '{}'); } catch (_) {}

            selectedIndices.forEach(idx => {
                const addr = addresses[idx];
                const key = `${addr.address}|${addr.city}|${addr.zip}`.toUpperCase();
                if (mailedTracker[key]) {
                    mailedTracker[key].count++;
                    mailedTracker[key].lastMailed = today;
                } else {
                    mailedTracker[key] = { count: 1, firstMailed: today, lastMailed: today };
                }
                count++;
            });

            try {
                localStorage.setItem('poolscraper_mailed_v2', JSON.stringify(mailedTracker));
            } catch (e) {
                if (e.name === 'QuotaExceededError') showToast('Storage full ‚Äî mailed status not saved', 'error');
            }
            updateStats();
            clearBulkSelection();
            showToast(`üì¨ ${count} addresses marked as mailed`, 'success');
        }

        function clearBulkSelection() {
            selectedIndices.clear();
            document.getElementById('selectAllCheckbox').checked = false;
            updateBulkActionBar();
            renderList();
        }

        // ============== UNDO FUNCTION ==============
        function saveForUndo(type, idx, oldValue) {
            undoStack.push({ type, idx, oldValue });
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            document.getElementById('undoBtn').disabled = false;
        }

        function undoLastAction() {
            if (undoStack.length === 0) return;

            const action = undoStack.pop();

            if (action.type === 'status') {
                addresses[action.idx].status = action.oldValue || 'unreviewed';
                addresses[action.idx].verifiedAt = null;
            } else if (action.type === 'bulk-status') {
                action.changes.forEach(c => {
                    addresses[c.idx].status = c.oldStatus || 'unreviewed';
                    addresses[c.idx].verifiedAt = null;
                });
            }

            saveData();
            updateStats();
            renderList();
            showToast('‚Ü©Ô∏è Action undone');

            if (undoStack.length === 0) {
                document.getElementById('undoBtn').disabled = true;
            }
        }

        // ============== SKIP TO UNVERIFIED ==============
        function skipToUnverified() {
            const nextUnreviewed = addresses.findIndex((a, i) => !a.status || a.status === 'unreviewed');
            if (nextUnreviewed !== -1) {
                selectAddress(nextUnreviewed);
                showToast(`Jumped to #${nextUnreviewed + 1}`);
            } else {
                showToast('All addresses have been reviewed!', 'success');
            }
        }

        // Add new address
        function addNewAddress() {
            const name = document.getElementById('addName').value.trim() || 'Current Resident';
            const street = document.getElementById('addStreet').value.trim();
            const city = document.getElementById('addCity').value.trim();
            const state = document.getElementById('addState').value.trim() || 'FL';
            const zip = document.getElementById('addZip').value.trim();
            const status = document.getElementById('addStatus').value;

            if (!street) {
                showToast('Street address is required', 'error');
                return;
            }
            if (!city) {
                showToast('City is required', 'error');
                return;
            }
            if (state.length !== 2 || !/^[A-Z]{2}$/i.test(state)) {
                showToast('State must be a 2-letter abbreviation', 'error');
                return;
            }
            if (zip && !/^\d{5}(-\d{4})?$/.test(zip)) {
                showToast('ZIP must be 5 or 9 digits (e.g. 32801 or 32801-1234)', 'error');
                return;
            }

            const addr = {
                id: Date.now(),
                name: name,
                address: street,
                city: city,
                state: state,
                zip: zip,
                value: '',
                year: '',
                age: '',
                status: status,
                verifiedAt: new Date().toISOString()
            };
            addr.fullAddress = `${addr.address}, ${addr.city}, ${addr.state} ${addr.zip}`;
            addr.key = addr.fullAddress.toUpperCase().replace(/[^A-Z0-9]/g, '');

            addresses.push(addr);
            saveData();
            updateStats();
            renderList();
            selectAddress(addresses.length - 1);
            closeAddModal();

            showToast('Address added!', 'success');
        }

        function closeAddModal() {
            document.getElementById('addModal').classList.remove('show');
        }

        function showImportModal() {
            document.getElementById('importModal').classList.add('show');
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('show');
        }

        // Export dropdown
        function toggleExportMenu() {
            document.getElementById('exportDropdownMenu').classList.toggle('show');
        }
        function closeExportMenu() {
            document.getElementById('exportDropdownMenu').classList.remove('show');
        }
        document.addEventListener('click', function(e) {
            const wrap = document.querySelector('.export-dropdown-wrap');
            if (wrap && !wrap.contains(e.target)) closeExportMenu();
        });

        function showHelp() {
            document.getElementById('helpModal').classList.add('show');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('show');
        }

        function loadFromScraper() {
            let rawData = [];

            // Primary: atomic transfer key (v2)
            const transfer = localStorage.getItem('poolscraper_transfer');
            if (transfer) {
                try {
                    const payload = JSON.parse(transfer);
                    rawData = payload.results || [];
                } catch (e) { console.warn('[verifier] transfer parse:', e.message); }
            }

            // Fallback: legacy key (one-time backward compat)
            if (rawData.length === 0) {
                try {
                    const legacy = JSON.parse(localStorage.getItem('poolscraper_filtered') || 'null');
                    if (legacy && Array.isArray(legacy.results)) rawData = legacy.results;
                } catch (e) { console.warn('[verifier] legacy parse:', e.message); }
            }

            if (rawData.length === 0) {
                showToast('No data sent from Scraper. Use "Send to Identifier" in Pool Scraper first.', 'error');
                return;
            }

            // Map from Scraper format to Identifier format
            const data = rawData.map(r => ({
                name: r.recipient || 'Current Resident',
                address: r.address || '',
                city: r.city || '',
                state: r.state || 'FL',
                zip: r.zipcode || '',
                subdivision: r.subdivision || '',
                value: r.propertyValue || '',
                year: r.yearBuilt || '',
                age: r.poolAge || '',
                saleDate: r.saleDate || '',
                propertyAddress: r.propertyAddress || '',
                mailingAddress: r.mailingAddress || ''
            }));

            // Load saved verification status
            const savedData = JSON.parse(localStorage.getItem('poolVerifierData') || '{}');

            const incoming = data.map((d, i) => {
                const addr = {
                    id: i + 1,
                    name: d.name || 'Current Resident',
                    address: d.address || '',
                    city: d.city || '',
                    state: d.state || 'FL',
                    zip: d.zip || '',
                    subdivision: expandSubdivisionAbbrevs(d.subdivision || ''),
                    value: d.value || '',
                    year: d.year || '',
                    age: d.age || '',
                    saleDate: d.saleDate || '',
                    propertyAddress: d.propertyAddress || '',
                    mailingAddress: d.mailingAddress || '',
                    status: 'unreviewed',
                    verifiedAt: null
                };
                addr.fullAddress = `${addr.address}, ${addr.city}, ${addr.state} ${addr.zip}`;
                addr.key = addr.fullAddress.toUpperCase().replace(/[^A-Z0-9]/g, '');

                // Restore saved status
                if (savedData[addr.key]) {
                    addr.status = savedData[addr.key].status ?? 'unreviewed';
                    addr.verifiedAt = savedData[addr.key].verifiedAt ?? null;
                }

                return addr;
            });

            // Replace addresses with fresh scraper data
            addresses = incoming;

            // Persist immediately before clearing transfer keys
            saveVerifierSession();

            // Clear consumed transfer key ‚Äî verifier session is now source of truth
            localStorage.removeItem('poolscraper_transfer');
            localStorage.removeItem('poolscraper_filtered'); // legacy cleanup

            document.getElementById('emptyMap').style.display = 'none';
            document.getElementById('currentPanel').style.display = 'block';
            document.getElementById('actionPanel').style.display = 'flex';

            renderList();
            updateStats();

            if (addresses.length > 0) {
                selectAddress(0);
            }

            // Populate subdivision filter dropdown
            populateSubdivisionFilter();

            const subdivs = [...new Set(addresses.map(a => a.subdivision).filter(s => s))];
            const sourceLabel = transfer ? 'filtered' : 'all';
            showToast(`Loaded ${addresses.length} ${sourceLabel} addresses (${subdivs.length} subdivisions)`, 'success');
        }

        // Export
        function exportVerified() {
            if (addresses.length === 0) {
                showToast('No addresses to export', 'error');
                return;
            }
            updateExportCount();
            // Pre-fill filename with top subdivision
            const subdivCounts = {};
            addresses.forEach(a => {
                const s = (a.subdivision || '').trim();
                if (s) subdivCounts[s] = (subdivCounts[s] || 0) + 1;
            });
            const topSubdiv = Object.entries(subdivCounts).sort((a, b) => b[1] - a[1])[0];
            const nameField = document.getElementById('expFileName');
            if (!nameField.value && topSubdiv) {
                nameField.value = topSubdiv[0].replace(/\s+/g, '_') + '_' + new Date().toISOString().slice(0, 10);
            }
            document.getElementById('exportModal').classList.add('show');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('show');
        }

        // One-click VistaPrint export ‚Äî verified addresses only, 6 columns
        function quickVistaPrint() {
            const verified = addresses.filter(a => a.status === STATUS.VERIFIED);
            if (verified.length === 0) {
                showToast('No verified addresses to export', 'error');
                return;
            }

            const headers = ['Recipient', 'Company', 'Address', 'City', 'State', 'Zipcode'];
            const rows = verified.map(a => {
                const resolved = resolveMailAddress(a);
                return [
                    `"${csvSafe(a.name || 'Current Resident')}"`,
                    `"${csvSafe(a.company || '')}"`,
                    `"${csvSafe(resolved.address || a.address || '')}"`,
                    `"${csvSafe(a.city || '')}"`,
                    `"${csvSafe(a.state || '')}"`,
                    `"${csvSafe(a.zip || '')}"`
                ].join(',');
            });
            const csv = [headers.join(','), ...rows].join('\n');

            const subdivCounts = {};
            verified.forEach(a => {
                const s = (a.subdivision || '').trim();
                if (s) subdivCounts[s] = (subdivCounts[s] || 0) + 1;
            });
            const topSubdiv = Object.entries(subdivCounts).sort((a, b) => b[1] - a[1])[0];
            const subdivName = topSubdiv ? topSubdiv[0].replace(/\s+/g, '_') : 'Verified';
            const date = new Date().toISOString().slice(0, 10);
            const fileName = `VistaPrint_${subdivName}_${verified.length}_${date}.csv`;

            downloadFile(csv, fileName);
            showToast(`Exported ${verified.length} verified addresses ‚Üí ${fileName}`, 'success');
        }

        function updateExportCount() {
            const filter = document.getElementById('exportFilter').value;
            let count = 0;
            if (filter === 'verified') count = addresses.filter(a => a.status === STATUS.VERIFIED).length;
            else if (filter === 'all-reviewed') count = addresses.filter(a => a.status === STATUS.VERIFIED || a.status === STATUS.NO_POOL).length;
            else count = addresses.length;
            document.getElementById('exportCount').textContent = `${count} addresses will be exported`;
        }

        function togglePerSubdiv() {
            const checked = document.getElementById('expPerSubdiv').checked;
            document.getElementById('singleFileNameWrap').style.display = checked ? 'none' : 'block';
            const preview = document.getElementById('perSubdivPreview');
            if (!checked) { preview.style.display = 'none'; return; }

            // Show subdivision breakdown
            const filter = document.getElementById('exportFilter').value;
            let pool = [];
            if (filter === 'verified') pool = addresses.filter(a => a.status === STATUS.VERIFIED);
            else if (filter === 'all-reviewed') pool = addresses.filter(a => a.status === STATUS.VERIFIED || a.status === STATUS.NO_POOL);
            else pool = addresses;

            const counts = {};
            pool.forEach(a => {
                const s = (a.subdivision || '').trim() || 'No Subdivision';
                counts[s] = (counts[s] || 0) + 1;
            });

            const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
            preview.innerHTML = sorted.map(([name, count]) =>
                `<div style="display:flex; justify-content:space-between; padding:3px 0; font-size:12px; border-bottom:1px solid var(--border);">
                    <span style="color:var(--text);">${escapeHtml(name)}</span>
                    <span style="color:var(--accent); font-weight:600;">${count} leads</span>
                </div>`
            ).join('');
            preview.style.display = 'block';
        }

        function getExportColumns(isRouteFormat) {
            const cols = [];
            if (isRouteFormat) cols.push({ key: 'stop', header: 'Stop #' });
            if (document.getElementById('expRecipient').checked) cols.push({ key: 'name', header: 'Recipient' });
            if (document.getElementById('expCompany').checked) cols.push({ key: 'company', header: 'Company' });
            if (document.getElementById('expAddress').checked) cols.push({ key: 'address', header: 'Address' });
            if (document.getElementById('expCity').checked) cols.push({ key: 'city', header: 'City' });
            if (document.getElementById('expState').checked) cols.push({ key: 'state', header: 'State' });
            if (document.getElementById('expZip').checked) cols.push({ key: 'zip', header: 'Zipcode' });
            if (document.getElementById('expSubdivision')?.checked) cols.push({ key: 'subdivision', header: 'Subdivision' });
            if (document.getElementById('expValue').checked) cols.push({ key: 'value', header: 'PropertyValue' });
            if (document.getElementById('expYear').checked) cols.push({ key: 'year', header: 'YearBuilt' });
            if (document.getElementById('expAge').checked) cols.push({ key: 'age', header: 'PoolAge' });
            if (document.getElementById('expStatus')?.checked) cols.push({ key: 'status', header: 'Status' });
            if (document.getElementById('expSaleDate')?.checked) cols.push({ key: 'saleDate', header: 'SaleDate' });
            if (document.getElementById('expPropertyAddress')?.checked) cols.push({ key: 'propertyAddress', header: 'PropertyAddress' });
            if (document.getElementById('expMailingAddress')?.checked) cols.push({ key: 'mailingAddress', header: 'MailingAddress' });
            if (document.getElementById('expAddressSource')?.checked) cols.push({ key: 'addressSource', header: 'AddressSource' });
            if (document.getElementById('expVerifiedAt').checked) cols.push({ key: 'verifiedAt', header: 'VerifiedDate' });
            return cols;
        }

        // Prevent CSV injection: prefix formula-triggering characters with a single quote
        function csvSafe(val) {
            const s = String(val).replace(/"/g, '""');
            if (/^[=+\-@\t\r]/.test(s)) return "'" + s;
            return s;
        }

        function buildCSV(records, cols) {
            let csv = cols.map(c => c.header).join(',') + '\n';
            records.forEach((a, idx) => {
                const resolved = resolveMailAddress(a);
                const row = cols.map(c => {
                    let val = a[c.key] || '';
                    if (c.key === 'stop') val = idx + 1;
                    if (c.key === 'company') val = a.company || '';
                    if (c.key === 'name') val = a.name || 'Current Resident';
                    if (c.key === 'address') val = resolved.address || a.address;
                    if (c.key === 'addressSource') val = resolved.source;
                    if (c.key === 'verifiedAt' && val) val = new Date(val).toLocaleDateString('en-CA');
                    if (c.key === 'status') val = a.status === STATUS.VERIFIED ? 'Has Pool' : (a.status === STATUS.NO_POOL ? 'No Pool' : 'Pending');
                    return `"${csvSafe(val)}"`;
                });
                csv += row.join(',') + '\n';
            });
            return csv;
        }

        function sortForRoute(records) {
            return [...records].sort((a, b) => {
                const zipA = (a.zip || '').substring(0, 5);
                const zipB = (b.zip || '').substring(0, 5);
                if (zipA !== zipB) return zipA.localeCompare(zipB);
                if (a.city !== b.city) return (a.city || '').localeCompare(b.city || '');
                const streetA = (a.address || '').replace(/^\d+\s*/, '');
                const streetB = (b.address || '').replace(/^\d+\s*/, '');
                if (streetA !== streetB) return streetA.localeCompare(streetB);
                const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0', 10);
                const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0', 10);
                return numA - numB;
            });
        }

        // --- Folder-based per-subdivision export (File System Access API) ---
        async function saveToDirectory(entries, cols, isRouteFormat) {
            const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
            for (const [subdiv, records] of entries) {
                const sorted = isRouteFormat ? sortForRoute(records) : records;
                const csv = buildCSV(sorted, cols);
                const safeName = subdiv.replace(/[^a-zA-Z0-9 _-]/g, '').replace(/\s+/g, '_');
                const fileHandle = await dirHandle.getFileHandle(`${safeName}.csv`, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(csv);
                await writable.close();
            }
        }

        // --- ZIP fallback (no external library, STORE method) ---
        function saveAsZip(entries, cols, isRouteFormat) {
            const files = [];
            for (const [subdiv, records] of entries) {
                const sorted = isRouteFormat ? sortForRoute(records) : records;
                const csv = buildCSV(sorted, cols);
                const safeName = subdiv.replace(/[^a-zA-Z0-9 _-]/g, '').replace(/\s+/g, '_');
                files.push({ name: `${safeName}.csv`, data: new TextEncoder().encode(csv) });
            }

            // CRC32 lookup table
            const crcTable = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                crcTable[i] = c;
            }
            function crc32(buf) {
                let crc = 0xFFFFFFFF;
                for (let i = 0; i < buf.length; i++) crc = crcTable[(crc ^ buf[i]) & 0xFF] ^ (crc >>> 8);
                return (crc ^ 0xFFFFFFFF) >>> 0;
            }

            // Build zip in memory (STORE, no compression)
            const parts = [];
            const centralDir = [];
            let offset = 0;

            for (const f of files) {
                const nameBytes = new TextEncoder().encode(f.name);
                const crc = crc32(f.data);
                const size = f.data.length;

                // Local file header (30 + name length)
                const local = new Uint8Array(30 + nameBytes.length);
                const lv = new DataView(local.buffer);
                lv.setUint32(0, 0x04034b50, true);  // signature
                lv.setUint16(4, 20, true);           // version needed
                lv.setUint16(6, 0, true);            // flags
                lv.setUint16(8, 0, true);            // compression (STORE)
                lv.setUint16(10, 0, true);           // mod time
                lv.setUint16(12, 0, true);           // mod date
                lv.setUint32(14, crc, true);
                lv.setUint32(18, size, true);        // compressed size
                lv.setUint32(22, size, true);        // uncompressed size
                lv.setUint16(26, nameBytes.length, true);
                lv.setUint16(28, 0, true);           // extra length
                local.set(nameBytes, 30);
                parts.push(local, f.data);

                // Central directory entry (46 + name length)
                const cd = new Uint8Array(46 + nameBytes.length);
                const cv = new DataView(cd.buffer);
                cv.setUint32(0, 0x02014b50, true);   // signature
                cv.setUint16(4, 20, true);            // version made by
                cv.setUint16(6, 20, true);            // version needed
                cv.setUint16(8, 0, true);             // flags
                cv.setUint16(10, 0, true);            // compression
                cv.setUint16(12, 0, true);            // mod time
                cv.setUint16(14, 0, true);            // mod date
                cv.setUint32(16, crc, true);
                cv.setUint32(20, size, true);
                cv.setUint32(24, size, true);
                cv.setUint16(28, nameBytes.length, true);
                cv.setUint16(30, 0, true);            // extra length
                cv.setUint16(32, 0, true);            // comment length
                cv.setUint16(34, 0, true);            // disk start
                cv.setUint16(36, 0, true);            // internal attrs
                cv.setUint32(38, 0, true);            // external attrs
                cv.setUint32(42, offset, true);       // local header offset
                cd.set(nameBytes, 46);
                centralDir.push(cd);

                offset += local.length + f.data.length;
            }

            const cdStart = offset;
            let cdSize = 0;
            centralDir.forEach(cd => cdSize += cd.length);

            // End of central directory (22 bytes)
            const eocd = new Uint8Array(22);
            const ev = new DataView(eocd.buffer);
            ev.setUint32(0, 0x06054b50, true);
            ev.setUint16(4, 0, true);
            ev.setUint16(6, 0, true);
            ev.setUint16(8, files.length, true);
            ev.setUint16(10, files.length, true);
            ev.setUint32(12, cdSize, true);
            ev.setUint32(16, cdStart, true);
            ev.setUint16(20, 0, true);

            const blob = new Blob([...parts, ...centralDir, eocd], { type: 'application/zip' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Pool_Export_${new Date().toISOString().slice(0, 10)}.zip`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`Downloaded zip with ${files.length} subdivision files (${entries.reduce((s, e) => s + e[1].length, 0)} addresses)`, 'success');
        }

        async function doExport() {
            const filter = document.getElementById('exportFilter').value;
            const isRouteFormat = document.getElementById('expRouteFormat')?.checked;
            const perSubdiv = document.getElementById('expPerSubdiv')?.checked;

            let toExport = [];
            if (filter === 'verified') toExport = addresses.filter(a => a.status === STATUS.VERIFIED);
            else if (filter === 'all-reviewed') toExport = addresses.filter(a => a.status === STATUS.VERIFIED || a.status === STATUS.NO_POOL);
            else toExport = [...addresses];

            if (toExport.length === 0) {
                showToast('No addresses match the filter', 'error');
                return;
            }

            const cols = getExportColumns(isRouteFormat);
            if (cols.length === 0) {
                showToast('Select at least one column', 'error');
                return;
            }

            if (perSubdiv) {
                // Group by subdivision
                const groups = {};
                toExport.forEach(a => {
                    const sub = (a.subdivision || '').trim() || 'No_Subdivision';
                    if (!groups[sub]) groups[sub] = [];
                    groups[sub].push(a);
                });
                const entries = Object.entries(groups).sort((a, b) => b[1].length - a[1].length);

                if (window.showDirectoryPicker) {
                    try {
                        await saveToDirectory(entries, cols, isRouteFormat);
                        showToast(`Saved ${entries.length} files (${toExport.length} addresses) to folder`, 'success');
                    } catch (e) {
                        if (e.name === 'AbortError') return; // user cancelled
                        console.warn('[verifier] folder save failed, falling back to zip:', e.message);
                        saveAsZip(entries, cols, isRouteFormat);
                    }
                } else {
                    saveAsZip(entries, cols, isRouteFormat);
                }
                closeExportModal();
                return;
            } else {
                // Single file export
                if (isRouteFormat) toExport = sortForRoute(toExport);
                const csv = buildCSV(toExport, cols);

                const customName = (document.getElementById('expFileName').value || '').trim();
                const filterName = filter === 'verified' ? 'Verified' : filter === 'all-reviewed' ? 'Reviewed' : 'All';
                const fileName = customName
                    ? `${customName.replace(/\.csv$/i, '')}.csv`
                    : isRouteFormat ? `Pool_Route_${new Date().toISOString().slice(0,10)}.csv` : `Pool_${filterName}_${new Date().toISOString().slice(0,10)}.csv`;
                downloadFile(csv, fileName);
                showToast(`Exported ${toExport.length} addresses${isRouteFormat ? ' (route sorted)' : ''}`, 'success');
            }
            closeExportModal();
        }

        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Route functions
        function sortByRoute() {
            if (addresses.length === 0) { showToast('No addresses to sort', 'error'); return; }

            // Sort by subdivision first (walking clusters), then street, then house number
            addresses = [...addresses].sort((a, b) => {
                // 1. Group by subdivision (walking distance clusters)
                const subdivA = (a.subdivision || '').toLowerCase();
                const subdivB = (b.subdivision || '').toLowerCase();
                if (subdivA !== subdivB) return subdivA.localeCompare(subdivB);

                // 2. Within subdivision, group by zip
                const zipA = (a.zip || '').substring(0, 5);
                const zipB = (b.zip || '').substring(0, 5);
                if (zipA !== zipB) return zipA.localeCompare(zipB);

                // 3. Then by street name
                const streetA = (a.address || '').replace(/^\d+\s*/, '').toLowerCase();
                const streetB = (b.address || '').replace(/^\d+\s*/, '').toLowerCase();
                if (streetA !== streetB) return streetA.localeCompare(streetB);

                // 4. Then by house number (sequential for walking)
                const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0', 10);
                const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0', 10);
                return numA - numB;
            });

            // Reset to first address and update display
            currentIndex = 0;
            renderList();
            selectAddress(0);
            saveData();
            const subdivCount = [...new Set(addresses.map(a => a.subdivision).filter(s => s))].length;
            showToast(`Sorted by subdivision route (${subdivCount} subdivisions)`, 'success');
        }

        function openGoogleMapsRoute() {
            // Get verified addresses for route
            const verified = addresses.filter(a => a.status === STATUS.VERIFIED);
            const toRoute = verified.length > 0 ? verified : addresses;

            if (toRoute.length === 0) {
                showToast('No addresses for route', 'error');
                return;
            }

            // Google Maps supports up to 10 waypoints
            const maxStops = 10;
            const routeAddresses = toRoute.slice(0, maxStops).map(a => {
                return encodeURIComponent(`${a.address}, ${a.city}, ${a.state} ${a.zip}`);
            });

            if (routeAddresses.length === 0) {
                showToast('No valid addresses', 'error');
                return;
            }

            // Build Google Maps directions URL
            const mapsUrl = 'https://www.google.com/maps/dir/' + routeAddresses.join('/');
            window.open(mapsUrl, '_blank', 'noopener,noreferrer');
            showToast(`Opened ${routeAddresses.length} stops in Google Maps`, 'success');
        }

        // Populate subdivision filter dropdown
        function populateSubdivisionFilter() {
            const select = document.getElementById('subdivisionFilter');
            if (!select) return;

            const subdivs = [...new Set(addresses.map(a => a.subdivision).filter(s => s && s.trim()))].sort();

            select.innerHTML = '<option value="all">All Subdivisions (' + addresses.length + ')</option>';
            subdivs.forEach(s => {
                const count = addresses.filter(a => a.subdivision === s).length;
                select.innerHTML += `<option value="${escapeHtml(s)}">${escapeHtml(s)} (${count})</option>`;
            });
        }

        // Plot walking route for selected subdivision
        function plotSubdivisionRoute() {
            const subdivFilter = document.getElementById('subdivisionFilter')?.value || 'all';

            // Get addresses for selected subdivision
            let toRoute = addresses;
            if (subdivFilter !== 'all') {
                toRoute = addresses.filter(a => (a.subdivision || '').toLowerCase() === subdivFilter.toLowerCase());
            }

            if (toRoute.length === 0) {
                showToast('No addresses in selected subdivision', 'error');
                return;
            }

            // Sort by walking order: street name, then house number
            toRoute = [...toRoute].sort((a, b) => {
                const streetA = (a.address || '').replace(/^\d+\s*/, '').toLowerCase();
                const streetB = (b.address || '').replace(/^\d+\s*/, '').toLowerCase();
                if (streetA !== streetB) return streetA.localeCompare(streetB);
                const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0', 10);
                const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0', 10);
                return numA - numB;
            });

            const subdivName = subdivFilter === 'all' ? 'all addresses' : subdivFilter;

            // If more than 10 stops, show options
            if (toRoute.length > MAX_ROUTE_STOPS) {
                const choice = confirm(`${toRoute.length} stops in ${subdivName}.\n\nOK = View all as pins on map\nCancel = Open in batches of ${MAX_ROUTE_STOPS} (walking directions)`);

                if (choice) {
                    // View all as pins - no waypoint limit
                    openAllAsPins(toRoute, subdivName);
                } else {
                    // Open in batches of 10 with walking directions
                    openInBatches(toRoute, subdivName);
                }
            } else {
                // 10 or fewer - open as walking route
                openWalkingRoute(toRoute, subdivName);
            }
        }

        // Open all addresses as pins on Google Maps (no limit)
        function openAllAsPins(toRoute, label) {
            // Create numbered list for reference
            let stopList = toRoute.map((a, i) => `${i+1}. ${a.address}`).join('\n');

            // Copy to clipboard
            navigator.clipboard.writeText(stopList).then(() => {
                showToast('Stop list copied to clipboard!', 'success');
            }).catch(() => {});

            // Open Google Maps centered on first address with search for the area
            const centerAddr = toRoute[0];
            const searchQuery = encodeURIComponent(`${centerAddr.city}, ${centerAddr.state} ${centerAddr.zip}`);
            const mapsUrl = `https://www.google.com/maps/search/${searchQuery}/@${encodeURIComponent(centerAddr.address + ', ' + centerAddr.city)},17z`;
            window.open(mapsUrl, '_blank', 'noopener,noreferrer');

            // Show the stop list for reference (intentional: displays multi-line route list)
            // Show route stop list in a styled modal instead of blocking alert
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:9999;display:flex;align-items:center;justify-content:center;';
            overlay.onclick = () => overlay.remove();
            const modal = document.createElement('div');
            modal.style.cssText = 'background:#1e293b;color:#e2e8f0;border-radius:12px;padding:24px;max-width:420px;width:90%;max-height:70vh;overflow-y:auto;font-family:system-ui;';
            modal.innerHTML = `<h3 style="margin:0 0 12px;color:#38bdf8;">üìç ${escapeHtml(String(toRoute.length))} STOPS (walking order)</h3><pre style="white-space:pre-wrap;font-size:13px;line-height:1.6;margin:0 0 16px;">${escapeHtml(stopList)}</pre><p style="color:#94a3b8;font-size:12px;margin:0;">‚úì List copied to clipboard &nbsp; ‚úì Map opened to area</p><button onclick="this.closest('div[style*=fixed]').remove()" style="margin-top:12px;padding:8px 20px;background:#38bdf8;color:#0f172a;border:none;border-radius:6px;cursor:pointer;font-weight:600;">Close</button>`;
            modal.onclick = e => e.stopPropagation();
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        // Open walking directions in batches of 10
        function openInBatches(toRoute, label) {
            const batchSize = 10;
            const batches = Math.ceil(toRoute.length / batchSize);

            for (let i = 0; i < batches; i++) {
                const batch = toRoute.slice(i * batchSize, (i + 1) * batchSize);
                setTimeout(() => {
                    openWalkingRoute(batch, `${label} (Batch ${i + 1}/${batches})`);
                }, i * 1000); // Stagger window opens
            }

            showToast(`Opening ${batches} route batches for ${toRoute.length} stops`, 'success');
        }

        // Open walking route for up to 10 addresses
        function openWalkingRoute(toRoute, label) {
            const routeAddresses = toRoute.map(a => {
                return encodeURIComponent(`${a.address}, ${a.city}, ${a.state} ${a.zip}`);
            });

            let mapsUrl;
            if (routeAddresses.length === 1) {
                mapsUrl = `https://www.google.com/maps/search/${routeAddresses[0]}`;
            } else if (routeAddresses.length === 2) {
                mapsUrl = `https://www.google.com/maps/dir/?api=1&travelmode=walking&origin=${routeAddresses[0]}&destination=${routeAddresses[1]}`;
            } else {
                const waypoints = routeAddresses.slice(1, -1).join('|');
                mapsUrl = `https://www.google.com/maps/dir/?api=1&travelmode=walking&origin=${routeAddresses[0]}&destination=${routeAddresses[routeAddresses.length-1]}&waypoints=${waypoints}`;
            }

            window.open(mapsUrl, '_blank', 'noopener,noreferrer');
            showToast(`Walking route: ${routeAddresses.length} stops - ${label}`, 'success');
        }

        function exportRouteCSV() {
            if (addresses.length === 0) { showToast('No addresses to export', 'error'); return; }

            // Sort by route first
            const sorted = [...addresses].sort((a, b) => {
                const zipA = (a.zip || '').substring(0, 5);
                const zipB = (b.zip || '').substring(0, 5);
                if (zipA !== zipB) return zipA.localeCompare(zipB);
                if (a.city !== b.city) return (a.city || '').localeCompare(b.city || '');
                const streetA = (a.address || '').replace(/^\d+\s*/, '');
                const streetB = (b.address || '').replace(/^\d+\s*/, '');
                if (streetA !== streetB) return streetA.localeCompare(streetB);
                const numA = parseInt((a.address || '').match(/^\d+/)?.[0] || '0', 10);
                const numB = parseInt((b.address || '').match(/^\d+/)?.[0] || '0', 10);
                return numA - numB;
            });

            // Generate CSV with stop numbers
            const headers = ['Stop #', 'Name', 'Address', 'City', 'State', 'Zip', 'Status', 'Value'];
            const rows = sorted.map((a, i) => {
                return [
                    i + 1,
                    `"${(a.name || 'Current Resident').replace(/"/g, '""')}"`,
                    `"${(a.address || '').replace(/"/g, '""')}"`,
                    `"${(a.city || '').replace(/"/g, '""')}"`,
                    `"${(a.state || '').replace(/"/g, '""')}"`,
                    `"${(a.zip || '').replace(/"/g, '""')}"`,
                    `"${(a.status || 'pending').replace(/"/g, '""')}"`,
                    `"${(a.value || '').replace(/"/g, '""')}"`
                ].join(',');
            });

            const csv = headers.join(',') + '\n' + rows.join('\n');
            downloadFile(csv, `Route_${new Date().toISOString().slice(0,10)}.csv`);
            showToast(`Exported ${sorted.length} addresses with route order`, 'success');
        }

        // Expand common Florida subdivision abbreviations
        // Pre-compiled regex map for subdivision abbreviation expansion (V7: avoid recompiling in loop)
        const SUBDIV_ABBREV_RULES = (() => {
            const abbrevs = {
                'Brs ': "Bear's ", 'Brs$': "Bear's",
                'Lk ': 'Lake ', 'Lk$': 'Lake',
                'Lks ': 'Lakes ',
                'Est ': 'Estates ', 'Est$': 'Estates',
                'Ests ': 'Estates ',
                'Hts ': 'Heights ', 'Hts$': 'Heights',
                'Hgts ': 'Heights ',
                'Spgs ': 'Springs ', 'Spgs$': 'Springs',
                'Sprgs ': 'Springs ',
                'Crk ': 'Creek ', 'Crk$': 'Creek',
                'Vlg ': 'Village ', 'Vlg$': 'Village',
                'Vllg ': 'Village ',
                'Mnr ': 'Manor ', 'Mnr$': 'Manor',
                'Pnt ': 'Point ', 'Pt ': 'Point ',
                'Gdns ': 'Gardens ', 'Gdn ': 'Garden ',
                'Grvs ': 'Groves ', 'Grv ': 'Grove ',
                'Plc ': 'Place ',
                'Cir ': 'Circle ',
                'Ter ': 'Terrace ', 'Trce ': 'Trace ',
                'Xing ': 'Crossing ',
                'Ldg ': 'Landing ', 'Lndg ': 'Landing ',
                'Rdg ': 'Ridge ', 'Rdg$': 'Ridge',
                'Vly ': 'Valley ', 'Vw ': 'View ',
                'Hls ': 'Hills ', 'Hl ': 'Hill ',
                'Rnch ': 'Ranch ', 'Rch ': 'Ranch ',
                'Plns ': 'Plains ', 'Pln ': 'Plain ',
                'Mdws ': 'Meadows ', 'Mdw ': 'Meadow ',
                'Oks ': 'Oaks ', 'Wds ': 'Woods ',
                'Frst ': 'Forest ', 'Fst ': 'Forest ',
                'Pk ': 'Park ', 'Prk ': 'Park ',
                'Ctr ': 'Center ', 'Cntr ': 'Center ',
                'Shrs ': 'Shores ', 'Bch ': 'Beach ',
                'Isl ': 'Isle ', 'Twn ': 'Town ',
                'Cmns ': 'Commons ', 'Comm ': 'Commons ',
                'Res ': 'Reserve ', 'Rsrv ': 'Reserve ', 'Rsv ': 'Reserve ',
                'Plnt ': 'Plantation ', 'Plntn ': 'Plantation ',
                'Addn ': 'Addition ', 'Add ': 'Addition ',
                'Rplt ': 'Replat ', 'Rp ': 'Replat ',
                'Ut ': 'Unit ', 'Un ': 'Unit ',
                'Sec ': 'Section ', 'Blk ': 'Block ',
                'Tr ': 'Tract ', 'Lot ': 'Lot '
            };
            return Object.entries(abbrevs).map(([abbr, full]) => {
                if (abbr.endsWith('$')) {
                    const pattern = abbr.slice(0, -1);
                    return { regex: new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'gi'), replacement: full.trim() };
                }
                return { regex: new RegExp(abbr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'), replacement: full };
            });
        })();

        function expandSubdivisionAbbrevs(str) {
            if (!str) return '';
            let result = str;
            for (const { regex, replacement } of SUBDIV_ABBREV_RULES) {
                regex.lastIndex = 0;
                result = result.replace(regex, replacement);
            }
            return result.trim();
        }

        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show ' + type;
            setTimeout(() => toast.className = 'toast', 3000);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Escape closes any open modal
            if (e.key === 'Escape') {
                closeHelp();
                closeAddModal();
                closeImportModal();
                closeExportModal();
                return;
            }

            // ? shows help (works even when no addresses loaded)
            if (e.key === '?' || (e.shiftKey && e.key === '/')) {
                showHelp();
                return;
            }

            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
            // Guard: don't fire shortcuts while a modal is open
            if (document.querySelector('.modal.show')) return;
            if (addresses.length === 0) return;

            switch(e.key.toLowerCase()) {
                case 'y': markAs('verified'); break;
                case 'n': markAs('no-pool'); break;
                case 'p': markAs('pending'); break;
                case 'm': markAsMailed(); break;
                case 'arrowright': goToNext(); break;
                case 'arrowleft': goToPrev(); break;
                case 'g': openInGoogleMaps(); break;
                case 's': skipToUnverified(); break;
                case 'u': undoLastAction(); break;
                case 'z': if (e.ctrlKey || e.metaKey) { e.preventDefault(); undoLastAction(); } break;
            }
        });

        // Drag and drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        const MAX_CSV_SIZE_BYTES = 5 * 1024 * 1024; // 5MB
        document.body.addEventListener('drop', e => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (!file) return;
            if (!file.name.endsWith('.csv') && file.type !== 'text/csv') {
                showToast('Only CSV files are accepted', 'error');
                return;
            }
            if (file.size > MAX_CSV_SIZE_BYTES) {
                showToast('File too large (max 5MB)', 'error');
                return;
            }
            loadCSV({ target: { files: [file] } });
        });

        // Clear all data
        function clearAllData() {
            if (!confirm('Clear all verification data? This cannot be undone.')) return;
            localStorage.removeItem('poolVerifierData');
            localStorage.removeItem('poolVerifier_session');
            localStorage.removeItem('poolscraper_filtered');
            addresses = [];
            currentIndex = -1;
            document.getElementById('addressList').innerHTML = '<div class="empty-state"><p>Load a CSV to begin</p></div>';
            document.getElementById('currentPanel').style.display = 'none';
            document.getElementById('actionPanel').style.display = 'none';
            document.getElementById('emptyMap').style.display = 'flex';
            document.getElementById('mapFrame').src = '';
            updateStats();
            showToast('All data cleared', 'success');
        }
    </script>
</body>
</html>
